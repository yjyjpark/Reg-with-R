<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 장 다중선형회귀모형 | R에 의한 회귀분석</title>
  <meta name="description" content="한신대학교 응용통계학과 전공 과목 회귀분석및실습의 교재로 사용되고 있습니다." />
  <meta name="generator" content="bookdown 0.38 and GitBook 2.6.7" />

  <meta property="og:title" content="4 장 다중선형회귀모형 | R에 의한 회귀분석" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="한신대학교 응용통계학과 전공 과목 회귀분석및실습의 교재로 사용되고 있습니다." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 장 다중선형회귀모형 | R에 의한 회귀분석" />
  
  <meta name="twitter:description" content="한신대학교 응용통계학과 전공 과목 회귀분석및실습의 교재로 사용되고 있습니다." />
  

<meta name="author" content="박동련" />


<meta name="date" content="2024-04-20" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="simple-reg-infer.html"/>
<link rel="next" href="reg-diag.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>머리말</a></li>
<li class="chapter" data-level="1" data-path="ch1.html"><a href="ch1.html"><i class="fa fa-check"></i><b>1</b> 회귀모형</a>
<ul>
<li class="chapter" data-level="1.1" data-path="ch1.html"><a href="ch1.html#반응변수와-설명변수-사이의-관계-설정"><i class="fa fa-check"></i><b>1.1</b> 반응변수와 설명변수 사이의 관계 설정</a></li>
<li class="chapter" data-level="1.2" data-path="ch1.html"><a href="ch1.html#회귀분석의-목적"><i class="fa fa-check"></i><b>1.2</b> 회귀분석의 목적</a></li>
<li class="chapter" data-level="1.3" data-path="ch1.html"><a href="ch1.html#회귀모형의-종류"><i class="fa fa-check"></i><b>1.3</b> 회귀모형의 종류</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="ch1.html"><a href="ch1.html#모수적-회귀모형"><i class="fa fa-check"></i><b>1.3.1</b> 모수적 회귀모형</a></li>
<li class="chapter" data-level="1.3.2" data-path="ch1.html"><a href="ch1.html#비모수적-회귀모형"><i class="fa fa-check"></i><b>1.3.2</b> 비모수적 회귀모형</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="ch1.html"><a href="ch1.html#r의-역할"><i class="fa fa-check"></i><b>1.4</b> R의 역할</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="simple-reg.html"><a href="simple-reg.html"><i class="fa fa-check"></i><b>2</b> 단순선형회귀모형</a>
<ul>
<li class="chapter" data-level="2.1" data-path="simple-reg.html"><a href="simple-reg.html#단순회귀모형의-설정"><i class="fa fa-check"></i><b>2.1</b> 단순회귀모형의 설정</a></li>
<li class="chapter" data-level="2.2" data-path="simple-reg.html"><a href="simple-reg.html#회귀계수의-최소제곱추정"><i class="fa fa-check"></i><b>2.2</b> 회귀계수의 최소제곱추정</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="simple-reg.html"><a href="simple-reg.html#모수-beta_0와-beta_1의-추정"><i class="fa fa-check"></i><b>2.2.1</b> 모수 <span class="math inline">\(\beta_{0}\)</span>와 <span class="math inline">\(\beta_{1}\)</span>의 추정</a></li>
<li class="chapter" data-level="2.2.2" data-path="simple-reg.html"><a href="simple-reg.html#section-property-lse"><i class="fa fa-check"></i><b>2.2.2</b> 최소제곱추정량의 특성</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="simple-reg.html"><a href="simple-reg.html#section-simple-sigma"><i class="fa fa-check"></i><b>2.3</b> 오차분산 <span class="math inline">\(\sigma^{2}\)</span>의 추정</a></li>
<li class="chapter" data-level="2.4" data-path="simple-reg.html"><a href="simple-reg.html#연습문제"><i class="fa fa-check"></i><b>2.4</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html"><i class="fa fa-check"></i><b>3</b> 단순선형회귀모형의 추론</a>
<ul>
<li class="chapter" data-level="3.1" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#회귀계수-beta_1에-대한-추론"><i class="fa fa-check"></i><b>3.1</b> 회귀계수 <span class="math inline">\(\beta_{1}\)</span>에 대한 추론</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#hatbeta_1의-표본분포"><i class="fa fa-check"></i><b>3.1.1</b> <span class="math inline">\(\hat{\beta}_{1}\)</span>의 표본분포</a></li>
<li class="chapter" data-level="3.1.2" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#section-ci-beta1"><i class="fa fa-check"></i><b>3.1.2</b> <span class="math inline">\(\beta_{1}\)</span>의 신뢰구간</a></li>
<li class="chapter" data-level="3.1.3" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#section-test-beta1"><i class="fa fa-check"></i><b>3.1.3</b> <span class="math inline">\(\beta_{1}\)</span>에 대한 가설검정</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#회귀계수-beta_0에-대한-추론"><i class="fa fa-check"></i><b>3.2</b> 회귀계수 <span class="math inline">\(\beta_{0}\)</span>에 대한 추론</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#hatbeta_0-의-표본분포"><i class="fa fa-check"></i><b>3.2.1</b> <span class="math inline">\(\hat{\beta}_{0}\)</span> 의 표본분포</a></li>
<li class="chapter" data-level="3.2.2" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#beta_0의-신뢰구간"><i class="fa fa-check"></i><b>3.2.2</b> <span class="math inline">\(\beta_{0}\)</span>의 신뢰구간</a></li>
<li class="chapter" data-level="3.2.3" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#beta_0에-대한-가설검정"><i class="fa fa-check"></i><b>3.2.3</b> <span class="math inline">\(\beta_{0}\)</span>에 대한 가설검정</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#반응변수의-평균-eyx_o에-대한-신뢰구간-추정"><i class="fa fa-check"></i><b>3.3</b> 반응변수의 평균, <span class="math inline">\(E(Y|X_{o})\)</span>에 대한 신뢰구간 추정</a></li>
<li class="chapter" data-level="3.4" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#반응변수의-개별-관측값-예측"><i class="fa fa-check"></i><b>3.4</b> 반응변수의 개별 관측값 예측</a></li>
<li class="chapter" data-level="3.5" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#상관계수-두-변수-사이의-선형-연관성-측정"><i class="fa fa-check"></i><b>3.5</b> 상관계수 : 두 변수 사이의 선형 연관성 측정</a></li>
<li class="chapter" data-level="3.6" data-path="simple-reg-infer.html"><a href="simple-reg-infer.html#연습문제-1"><i class="fa fa-check"></i><b>3.6</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="multiple-reg.html"><a href="multiple-reg.html"><i class="fa fa-check"></i><b>4</b> 다중선형회귀모형</a>
<ul>
<li class="chapter" data-level="4.1" data-path="multiple-reg.html"><a href="multiple-reg.html#section-multi-model"><i class="fa fa-check"></i><b>4.1</b> 다중회귀모형의 설정</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="multiple-reg.html"><a href="multiple-reg.html#section-multi-fitting"><i class="fa fa-check"></i><b>4.1.1</b> 회귀계수의 추정</a></li>
<li class="chapter" data-level="4.1.2" data-path="multiple-reg.html"><a href="multiple-reg.html#다항회귀모형"><i class="fa fa-check"></i><b>4.1.2</b> 다항회귀모형</a></li>
<li class="chapter" data-level="4.1.3" data-path="multiple-reg.html"><a href="multiple-reg.html#section-dummy"><i class="fa fa-check"></i><b>4.1.3</b> 가변수 회귀모형</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="multiple-reg.html"><a href="multiple-reg.html#section-multi-infer"><i class="fa fa-check"></i><b>4.2</b> 다중회귀모형의 추론</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="multiple-reg.html"><a href="multiple-reg.html#회귀계수-추정량의-표본분포"><i class="fa fa-check"></i><b>4.2.1</b> 회귀계수 추정량의 표본분포</a></li>
<li class="chapter" data-level="4.2.2" data-path="multiple-reg.html"><a href="multiple-reg.html#section-multi-model-signif"><i class="fa fa-check"></i><b>4.2.2</b> 회귀모형의 유의성 검정</a></li>
<li class="chapter" data-level="4.2.3" data-path="multiple-reg.html"><a href="multiple-reg.html#개별-회귀계수-유의성-검정"><i class="fa fa-check"></i><b>4.2.3</b> 개별 회귀계수 유의성 검정</a></li>
<li class="chapter" data-level="4.2.4" data-path="multiple-reg.html"><a href="multiple-reg.html#두-회귀모형의-비교"><i class="fa fa-check"></i><b>4.2.4</b> 두 회귀모형의 비교</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="multiple-reg.html"><a href="multiple-reg.html#section-selection"><i class="fa fa-check"></i><b>4.3</b> 변수선택</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="multiple-reg.html"><a href="multiple-reg.html#section-fit-measure"><i class="fa fa-check"></i><b>4.3.1</b> 회귀모형의 평가 측도</a></li>
<li class="chapter" data-level="4.3.2" data-path="multiple-reg.html"><a href="multiple-reg.html#section-variable-criterion"><i class="fa fa-check"></i><b>4.3.2</b> 평가 측도에 의한 변수선택</a></li>
<li class="chapter" data-level="4.3.3" data-path="multiple-reg.html"><a href="multiple-reg.html#section-shrinkage"><i class="fa fa-check"></i><b>4.3.3</b> Shrinkage 방법</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="multiple-reg.html"><a href="multiple-reg.html#연습문제-2"><i class="fa fa-check"></i><b>4.4</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="reg-diag.html"><a href="reg-diag.html"><i class="fa fa-check"></i><b>5</b> 회귀모형의 진단</a>
<ul>
<li class="chapter" data-level="5.1" data-path="reg-diag.html"><a href="reg-diag.html#section-assumption-error"><i class="fa fa-check"></i><b>5.1</b> 회귀모형에 대한 진단</a></li>
<li class="chapter" data-level="5.2" data-path="reg-diag.html"><a href="reg-diag.html#section-influence-data"><i class="fa fa-check"></i><b>5.2</b> 관찰값에 대한 진단</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R에 의한 회귀분석</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="multiple-reg" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">4 장</span> 다중선형회귀모형<a href="multiple-reg.html#multiple-reg" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>반응변수의 변동을 하나의 설명변수만으로 충분하게 설명하는 것은 대부분의 경우 불가능할 것이다.
따라서 반응변수와 관련이 있을 것으로 보이는 여러 개의 설명변수를 모형에 포함시키는 다중회귀모형이 실제 상황에서 많이 사용되는 모형이 된다.
기본 가정 및 추론 방법에서는 단순회귀모형과 큰 차이가 있는 것은 아니지만, 모형에 여러 개의 설명변수가 포함되기 때문에 단순회귀모형에서는 없었던 문제들이 발생할 수 있다.</p>
<div id="section-multi-model" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> 다중회귀모형의 설정<a href="multiple-reg.html#section-multi-model" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>다중선형회귀모형에서는 반응변수 <span class="math inline">\(Y\)</span> 와 설명변수 <span class="math inline">\(X_{1}, \ldots, X_{k}\)</span> 사이에 다음의 관계가 존재한다고 가정한다.</p>
<p><span class="math display" id="eq:multi-reg">\[\begin{equation}
Y_{i} = \beta_{0} + \beta_{1}X_{1i} + \cdots + \beta_{k}X_{ki} + \varepsilon_{i},~~i=1,\ldots,n
\tag{4.1}
\end{equation}\]</span></p>
<p><span class="math inline">\(Y_{i}\)</span> 는 반응변수의 <span class="math inline">\(i\)</span> 번째 값, <span class="math inline">\(X_{ji}\)</span> 는 설명변수 <span class="math inline">\(X_{j}\)</span> 의 <span class="math inline">\(i\)</span> 번째 값을 나타내며,
모수 <span class="math inline">\(\beta_{0}, \beta_{1}, \ldots, \beta_{k}\)</span> 는 <span class="math inline">\((k+1)\)</span> 차원의 공간에서 정의되는 회귀평면을 구성하고 있다.
오차항 <span class="math inline">\(\varepsilon_{i}\)</span> 은 단순회귀모형에서와 동일한 의미를 갖고 있는 확률변수로서, <span class="math inline">\(\varepsilon_{i} \stackrel{iid}{\sim} N(0,\sigma^{2}),~i=1,\ldots,n\)</span> 의 가정을 하고 있다.</p>
<p>식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>의 관계식은 다음과 같이 풀어서 표현할 수 있으며,</p>
<p><span class="math display">\[\begin{align*}
Y_{1} &amp;= \beta_{0} + \beta_{1}X_{11} + \cdots + \beta_{k}X_{k1} + \varepsilon_{1} \\
Y_{2} &amp;= \beta_{0} + \beta_{1}X_{12} + \cdots + \beta_{k}X_{k2} + \varepsilon_{2} \\
\vdots \\
Y_{n} &amp;= \beta_{0} + \beta_{1}X_{1n} + \cdots + \beta_{k}X_{kn} + \varepsilon_{n}
\end{align*}\]</span></p>
<p>이것은 다시 다음과 같이 행렬의 형태로 정리할 수 있다.</p>
<p><span class="math display" id="eq:reg-matrix-1">\[
\begin{pmatrix}
Y_{1} \\ Y_{2} \\ \vdots  \\ Y_{n}
\end{pmatrix} =
\begin{pmatrix}
1 &amp; X_{11} &amp; \cdots &amp; X_{k1} \\
1 &amp; X_{12} &amp; \cdots &amp; X_{k2} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; X_{1n} &amp; \cdots &amp; X_{kn}
\end{pmatrix}
\begin{pmatrix}
\beta_{0} \\ \beta_{1} \\ \vdots \\ \beta_{k}
\end{pmatrix} +
\begin{pmatrix}
\varepsilon_{1} \\ \varepsilon_{2} \\ \vdots \\ \varepsilon_{n}
\end{pmatrix}
\tag{4.2}
\]</span>
또는 다음의 행렬로 표현할 수 있다.</p>
<p><span class="math display" id="eq:reg-matrix-2">\[\begin{equation}
\mathbf{Y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}
\tag{4.3}
\end{equation}\]</span></p>
<p><span class="math inline">\(\mathbf{Y}\)</span> 는 반응변수의 관찰값 벡터이고, <span class="math inline">\(\mathbf{X}\)</span> 는 설명변수의 관찰값 행렬로써 design matrix라고 하며, <span class="math inline">\(\boldsymbol{\beta}\)</span> 는 모수 벡터, <span class="math inline">\(\boldsymbol{\varepsilon}\)</span> 은 오차항 벡터이다.</p>
<div id="section-multi-fitting" class="section level3 hasAnchor" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> 회귀계수의 추정<a href="multiple-reg.html#section-multi-fitting" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>회귀계수 <span class="math inline">\(\beta_{0}, \beta_{1}, \ldots, \beta_{k}\)</span> 의 추정은 단순회귀모형의 경우와 동일한 방식으로 이루어진다.
반응변수 <span class="math inline">\(Y\)</span> 와 설명변수 <span class="math inline">\(X_{1}, \ldots, X_{k}\)</span> 에 대해 관측된 <span class="math inline">\(n\)</span> 개의 자료를 <span class="math inline">\((y_{i}, x_{1i}, \ldots, x_{ki}), ~i=1,\ldots,n\)</span> 이라고 하면, 다음의 <span class="math inline">\(RSS\)</span> 를 최소화하는 <span class="math inline">\(\hat{\boldsymbol{\beta}} = (\hat{\beta}_{0}, \hat{\beta}_{1}, \ldots, \hat{\beta}_{k})\)</span> 를 선택한다.</p>
<p><span class="math display" id="eq:multi-rss">\[\begin{equation}
RSS = \sum_{i=1}^{n} \left(y_{i} - \hat{\beta}_{0} - \hat{\beta}_{1}x_{1i} - \ldots -
\hat{\beta}_{k}x_{ki} \right)^{2}
\tag{4.4}
\end{equation}\]</span></p>
<p>식 <a href="multiple-reg.html#eq:multi-rss">(4.4)</a>의 <span class="math inline">\(RSS\)</span> 를 최소화시키는 추정값 <span class="math inline">\(\hat{\beta}_{0}, \ldots, \hat{\beta}_{k}\)</span> 를 구하기 위해서 <span class="math inline">\(RSS\)</span> 를 <span class="math inline">\(\hat{\beta}_{j}, ~j = 0, \ldots, k\)</span> 에 대하여 각각 편미분을 실시해서 다음의 <span class="math inline">\((k+1)\)</span> 개의 방정식을 얻는다.</p>
<p><span class="math display" id="eq:multi-lse-1">\[\begin{align}
\frac{\partial RSS}{\partial \hat{\beta}_{0}} &amp; = -2 \sum_{i=1}^{n}(y_{i}-\hat{\beta}_{0}-\hat{\beta}_{1}x_{1i}-\cdots-\hat{\beta}_{k}x_{ki})  = 0\\
\frac{\partial RSS}{\partial \hat{\beta}_{1}} &amp; = -2 \sum_{i=1}^{n}x_{1i}(y_{i}-\hat{\beta}_{0}-\hat{\beta}_{1}x_{1i}-\cdots-\hat{\beta}_{k}x_{ki})  = 0 \\
&amp;\vdots \\
\frac{\partial RSS}{\partial \hat{\beta}_{k}} &amp; = -2 \sum_{i=1}^{n}x_{ki}(y_{i}-\hat{\beta}_{0}-\hat{\beta}_{1}x_{1i}-\cdots-\hat{\beta}_{k}x_{ki})  = 0
\tag{4.5}
\end{align}\]</span></p>
<p>식 <a href="multiple-reg.html#eq:multi-lse-1">(4.5)</a>을 정리하면 다음과 같이 표현이 되며,</p>
<p><span class="math display" id="eq:multi-lse-2">\[\begin{align}
n\hat{\beta}_{0}+\hat{\beta}_{1}\sum_{i=1}^{n} x_{1i} + \cdots + \hat{\beta}_{k}\sum_{i=1}^{n} x_{ki} &amp;= \sum_{i=1}^{n} y_{i} \\
\hat{\beta}_{0}\sum_{i=1}^{n} x_{1i} + \hat{\beta}_{1}\sum_{i=1}^{n} x_{1i}^{2} + \cdots + \hat{\beta}_{k} \sum_{i=1}^{n} x_{1i}x_{ki} &amp;= \sum_{i=1}^{n} x_{1i}y_{i} \\
&amp; \vdots \\
\hat{\beta}_{0}\sum_{i=1}^{n} x_{ki} + \hat{\beta}_{1}\sum_{i=1}^{n} x_{ki}x_{1i} + \cdots + \hat{\beta}_{k}\sum_{i=1}^{n} x_{ki}^{2} &amp;= \sum_{i=1}^{n} x_{ki}y_{i}
\tag{4.6}
\end{align}\]</span></p>
<p>행렬의 형태로 표현하면 다음과 같이 된다.</p>
<p><span class="math display" id="eq:multi-lse-3">\[
\begin{pmatrix}
n &amp; \sum x_{1i} &amp; \cdots &amp; \sum x_{ki} \\
\sum x_{1i} &amp; \sum x_{1i}^{2} &amp; \cdots &amp; \sum x_{1i}x_{ki} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\sum x_{ki} &amp; \sum x_{ki}x_{1i} &amp; \cdots &amp; \sum x_{ki}^{2}
\end{pmatrix}
\begin{pmatrix}
\hat{\beta}_{0} \\ \hat{\beta}_{1} \\ \vdots \\ \hat{\beta}_{k}
\end{pmatrix}=
\begin{pmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{k1} &amp; x_{k2} &amp; \cdots &amp; x_{kn}
\end{pmatrix}
\begin{pmatrix}
y_{1} \\
y_{2} \\
\vdots \\
y_{n}
\end{pmatrix}
\tag{4.7}
\]</span></p>
<p>식 <a href="multiple-reg.html#eq:multi-lse-3">(4.7)</a>의 좌변 첫 번째 행렬은 식 <a href="multiple-reg.html#eq:reg-matrix-2">(4.3)</a>에서 정의된 행렬 <span class="math inline">\(\mathbf{X}\)</span> 로 다음과 같이 표현된다.</p>
<p><span class="math display" id="eq:multi-lse-4">\[
\begin{pmatrix}
n &amp; \sum x_{1i} &amp; \cdots &amp; \sum x_{ki} \\
\sum x_{1i} &amp; \sum x_{1i}^{2} &amp; \cdots &amp; \sum x_{1i}x_{ki} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\sum x_{ki} &amp; \sum x_{ki}x_{1i} &amp; \cdots &amp; \sum x_{ki}^{2}
\end{pmatrix}=
\mathbf{X}^{T}\mathbf{X}
\tag{4.8}
\]</span>
단, <span class="math inline">\(\mathbf{X}^{T}\)</span> 는 행렬 <span class="math inline">\(\mathbf{X}\)</span> 의 전치행렬이다.</p>
<p>따라서 다중회귀모형의 회귀계수에 대한 최소제곱추정량을 구하기 위한 방정식은 다음과 같이 주어진다.</p>
<p><span class="math display" id="eq:multi-lse-5">\[\begin{equation}
\mathbf{X}^{T}\mathbf{X}\hat{\boldsymbol{\beta}} = \mathbf{X}^{T}\mathbf{Y}
\tag{4.9}
\end{equation}\]</span></p>
<p>만일 <span class="math inline">\(\mathbf{X}^{T}\mathbf{X}\)</span> 의 역행렬이 존재한다면, 최소제곱추정량은 다음과 같이 표현된다.</p>
<p><span class="math display" id="eq:multi-lse-6">\[\begin{equation}
\hat{\boldsymbol{\beta}} = (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{Y}
\tag{4.10}
\end{equation}\]</span></p>
<p><span class="math inline">\(\bullet\)</span> 예제: 다중회귀모형의 회귀계수 추정</p>
<p>데이터 프레임 <code>mtcars</code>는 1974년 <span class="math inline">\(\textit{Motor Trend US}\)</span> 에 실린 32 종류 자동차 모델의 연비와 관련된 자료가 입력되어 있다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="multiple-reg.html#cb28-1" tabindex="-1"></a><span class="fu">str</span>(mtcars)</span>
<span id="cb28-2"><a href="multiple-reg.html#cb28-2" tabindex="-1"></a><span class="do">## &#39;data.frame&#39;:    32 obs. of  11 variables:</span></span>
<span id="cb28-3"><a href="multiple-reg.html#cb28-3" tabindex="-1"></a><span class="do">##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...</span></span>
<span id="cb28-4"><a href="multiple-reg.html#cb28-4" tabindex="-1"></a><span class="do">##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...</span></span>
<span id="cb28-5"><a href="multiple-reg.html#cb28-5" tabindex="-1"></a><span class="do">##  $ disp: num  160 160 108 258 360 ...</span></span>
<span id="cb28-6"><a href="multiple-reg.html#cb28-6" tabindex="-1"></a><span class="do">##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...</span></span>
<span id="cb28-7"><a href="multiple-reg.html#cb28-7" tabindex="-1"></a><span class="do">##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...</span></span>
<span id="cb28-8"><a href="multiple-reg.html#cb28-8" tabindex="-1"></a><span class="do">##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...</span></span>
<span id="cb28-9"><a href="multiple-reg.html#cb28-9" tabindex="-1"></a><span class="do">##  $ qsec: num  16.5 17 18.6 19.4 17 ...</span></span>
<span id="cb28-10"><a href="multiple-reg.html#cb28-10" tabindex="-1"></a><span class="do">##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...</span></span>
<span id="cb28-11"><a href="multiple-reg.html#cb28-11" tabindex="-1"></a><span class="do">##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...</span></span>
<span id="cb28-12"><a href="multiple-reg.html#cb28-12" tabindex="-1"></a><span class="do">##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...</span></span>
<span id="cb28-13"><a href="multiple-reg.html#cb28-13" tabindex="-1"></a><span class="do">##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...</span></span></code></pre></div>
<p>연비를 나타내는 <code>mpg</code>를 반응변수로 하고, 설명변수에는 차량의 무게를 나타내는 <code>wt</code>와 0.25 마일까지 도달하는 데 걸리는 시간을 나타내는 <code>qsec</code>을 선택해서 다중회귀모형을 설정하고 회귀계수를 추정해 보자.</p>
<p>단순회귀모형의 경우와 동일하게 다중회귀모형에서도 함수 <code>lm()</code>을 사용해서 모형적합을 실시할 수 있다.
하지만 단순회귀모형의 경우와 다르게 설명변수의 개수가 2개 이상이 되며, 복잡한 형태의 모형이 설정되는 경우도 많이 있기 때문에 다중회귀모형의 경우에는 함수 <code>lm()</code>에 지정되는 R 모형공식에 반응변수와 설명변수를 구분하는 <code>~</code> 기호 외에도 많은 기호가 사용된다.</p>
<table>
<caption>R 모형공식에서 사용되는 기호</caption>
<colgroup>
<col width="26%" />
<col width="73%" />
</colgroup>
<thead>
<tr class="header">
<th>기호</th>
<th>사용법</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>물결표 (<code>~</code>)</td>
<td>반응변수와 설명변수의 구분. 물결표의 왼쪽에는 반응변수, 오른쪽에는 설명변수를 둔다.</td>
</tr>
<tr class="even">
<td>플러스 (<code>+</code>)</td>
<td>모형에 포함된 설명변수의 구분. 반응변수 <code>y</code>와 설명변수 <code>x1</code>, <code>x2</code>, <code>x3</code>의 회귀모형은 <code>y ~ x1 + x2 + x3</code>로 표현된다.</td>
</tr>
<tr class="odd">
<td>콜론 (<code>:</code>)</td>
<td>설명변수 사이의 상호작용 표현. 반응변수 <code>y</code>와 설명변수 <code>x1</code>, <code>x2</code> 그리고 <code>x1</code>과 <code>x2</code>의 상호작용이 포함된 모형은 <code>y ~ x1 + x2 + x1:x2</code>로 표현된다.</td>
</tr>
<tr class="even">
<td>별표 (<code>*</code>)</td>
<td>주효과와 상호작용 효과를 포함한 모든 효과 표현. <code>y ~ x1 * x2 * x3</code>는 <code>y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3</code>를 의미한다.</td>
</tr>
<tr class="odd">
<td>윗꺽쇠 (<code>^</code>)</td>
<td>지정된 차수까지의 상호작용 표현. <code>y ~ (x1 + x2 + x3)^2</code>는 <code>y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3</code>을 의미한다.</td>
</tr>
<tr class="even">
<td>점 (<code>.</code>)</td>
<td>반응변수를 제외한 데이터 프레임에 있는 모든 변수. 만일 데이터 프레임에 <code>y</code>, <code>x1</code>, <code>x2</code>, <code>x3</code>가 있다면 <code>y ~ .</code> 은 <code>y ~ x1 + x2 + x3</code>을 의미한다.</td>
</tr>
<tr class="odd">
<td>마이너스(<code>-</code>)</td>
<td>회귀모형에서 제외되는 변수. <code>y ~ (x1 + x2 + x3)^2 – x2:x3</code>는 <code>y ~ x1 + x2 + x3 + x1:x2 + x1:x3</code>을 의미한다.</td>
</tr>
<tr class="even">
<td><code>- 1</code>, <code>+ 0</code></td>
<td>절편 제거. <code>y ~ x – 1</code> 혹은 <code>y ~ x + 0</code>은 원점을 지나는 회귀모형을 의미한다.</td>
</tr>
<tr class="odd">
<td><code>I()</code></td>
<td>괄호 안의 연산자를 수학 연산자로 인식. <code>y ~ x1 + I(x2+x3)</code>는 <span class="math inline">\(y=\beta_{0}+\beta_{1}x_{1}+\beta_{2}(x_{2}+x_{3})+\varepsilon\)</span> 모형을 의미한다.</td>
</tr>
</tbody>
</table>
<p>이제 <code>mpg</code>를 반응변수로, <code>wt</code>와 <code>qsec</code>을 설명변수로 하는 다중회귀모형을 적합해 보자.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="multiple-reg.html#cb29-1" tabindex="-1"></a>fit_m <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> wt <span class="sc">+</span> qsec, <span class="at">data =</span> mtcars)</span>
<span id="cb29-2"><a href="multiple-reg.html#cb29-2" tabindex="-1"></a>fit_m</span>
<span id="cb29-3"><a href="multiple-reg.html#cb29-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb29-4"><a href="multiple-reg.html#cb29-4" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb29-5"><a href="multiple-reg.html#cb29-5" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ wt + qsec, data = mtcars)</span></span>
<span id="cb29-6"><a href="multiple-reg.html#cb29-6" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb29-7"><a href="multiple-reg.html#cb29-7" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb29-8"><a href="multiple-reg.html#cb29-8" tabindex="-1"></a><span class="do">## (Intercept)           wt         qsec  </span></span>
<span id="cb29-9"><a href="multiple-reg.html#cb29-9" tabindex="-1"></a><span class="do">##     19.7462      -5.0480       0.9292</span></span></code></pre></div>
<p>적합된 모형식은 <span class="math inline">\(\widehat{\mbox{mpg}} = 19.74 - 5.047\mbox{ wt} + 0.929\mbox{ qsec}\)</span> 임을 알 수 있다.
추정된 회귀계수에 대한 해석은 단순회귀모형의 경우와 비슷하지만 제한 사항이 추가된다.
단순회귀모형에서는 하나의 설명변수만 있기 때문에 추정된 모형은 직선으로 표현되고, 따라서 해당 설명변수가 한 단위 증가했을 때 반응변수의 평균 변화량으로 회귀계수를 해석할 수 있었다.
하지만 다중회귀모형에서는 추정된 회귀모형이 직선이 아닌 2차원 이상에서 정의되는 평면이 되기 때문에 조금 더 복잡한 상황이 되는데, 그것은 어느 한 설명변수의 효과를 측정하기 위해서는 회귀평면을 구성하고 있는 다른 설명변수의 값이 고정되어야 하기 때문이다.</p>
<p>그림 <a href="multiple-reg.html#fig:ex4-1-1">4.1</a>에서는 <code>mpg</code>를 반응변수로, <code>wt</code>와 <code>qsec</code>을 설명변수로 하는 다중회귀모형으로 적합된 회귀평면이 작성되어 있다.
변수 <code>wt</code>의 추정된 회귀계수 <span class="math inline">\(-5.047\)</span> 은 <code>qsec</code>을 일정한 수준으로 고정한 상태에서 <code>wt</code>가 한 단위 증가했을 때 <code>mpg</code>의 평균 변화량을 나타내는 것인데, 그림에서 회귀평면이 <code>wt</code> 축의 양의 방향으로 급격하게 기우는 모습을 볼 수 있다.
또한 변수 <code>qsec</code>에 대한 추정된 회귀계수 <span class="math inline">\(0.929\)</span> 은 <code>wt</code>를 일정한 수준으로 고정한 상태에서 <code>qsec</code>이 한 단위 증가했을 때 <code>mpg</code>의 평균 변화량을 나타내는 것이며, 그림에서 회귀평면이 <code>qsec</code>의 양의 방향으로 완만하게 증가하는 모습을 볼 수 있다.</p>
<div class="figure"><span style="display:block;" id="fig:ex4-1-1"></span>
<img src="_main_files/figure-html/ex4-1-1-1.png" alt="설명변수가 2개인 다중회귀모형에서 추정된 회귀평면" width="576" />
<p class="caption">
그림 4.1: 설명변수가 2개인 다중회귀모형에서 추정된 회귀평면
</p>
</div>
<p><span class="math inline">\(\bullet\)</span> 예제: 행렬 <code>state.x77</code></p>
<p>행렬 <code>state.x77</code>은 미국 50개 주와 관련된 8개 변수로 구성되었다. 변수 <code>Life Exp</code>와 <code>HS Grad</code>는 이름 중간에 빈칸이 있으며, 각 주의 이름이 행렬의 row name으로 입력되어 있음을 알 수 있다.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="multiple-reg.html#cb30-1" tabindex="-1"></a>state.x77[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,]</span>
<span id="cb30-2"><a href="multiple-reg.html#cb30-2" tabindex="-1"></a><span class="do">##            Population Income Illiteracy Life Exp Murder HS Grad Frost   Area</span></span>
<span id="cb30-3"><a href="multiple-reg.html#cb30-3" tabindex="-1"></a><span class="do">## Alabama          3615   3624        2.1    69.05   15.1    41.3    20  50708</span></span>
<span id="cb30-4"><a href="multiple-reg.html#cb30-4" tabindex="-1"></a><span class="do">## Alaska            365   6315        1.5    69.31   11.3    66.7   152 566432</span></span>
<span id="cb30-5"><a href="multiple-reg.html#cb30-5" tabindex="-1"></a><span class="do">## Arizona          2212   4530        1.8    70.55    7.8    58.1    15 113417</span></span>
<span id="cb30-6"><a href="multiple-reg.html#cb30-6" tabindex="-1"></a><span class="do">## Arkansas         2110   3378        1.9    70.66   10.1    39.9    65  51945</span></span>
<span id="cb30-7"><a href="multiple-reg.html#cb30-7" tabindex="-1"></a><span class="do">## California      21198   5114        1.1    71.71   10.3    62.6    20 156361</span></span></code></pre></div>
<p>변수 <code>Murder</code>를 반응변수로, 나머지 7개 변수를 설명변수로 하는 다중회귀모형을 설정해 보자.
회귀분석을 원활하게 수행하기 위해서는 자료가 행렬이 아닌 데이터 프레임의 형태로 입력되어 있어야 한다.
행렬 <code>state.x77</code>을 데이터 프레임으로 변환하면서, 빈칸이 있는 변수 이름을 수정하고 반응변수를 마지막 변수로 이동시키자.
반응변수의 위치를 마지막으로 이동시킨 이유는 산점도 행렬을 작성하고 결과를 해석할 때 더 편리하기 때문이다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="multiple-reg.html#cb31-1" tabindex="-1"></a>states <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(state.x77) <span class="sc">|&gt;</span>  </span>
<span id="cb31-2"><a href="multiple-reg.html#cb31-2" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">Life_Exp =</span> <span class="st">`</span><span class="at">Life Exp</span><span class="st">`</span>, <span class="at">HS_Grad =</span> <span class="st">`</span><span class="at">HS Grad</span><span class="st">`</span>) <span class="sc">|&gt;</span>  </span>
<span id="cb31-3"><a href="multiple-reg.html#cb31-3" tabindex="-1"></a>  <span class="fu">relocate</span>(Murder, <span class="at">.after =</span> <span class="fu">last_col</span>())</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="multiple-reg.html#cb32-1" tabindex="-1"></a><span class="fu">str</span>(states)</span>
<span id="cb32-2"><a href="multiple-reg.html#cb32-2" tabindex="-1"></a><span class="do">## &#39;data.frame&#39;:    50 obs. of  8 variables:</span></span>
<span id="cb32-3"><a href="multiple-reg.html#cb32-3" tabindex="-1"></a><span class="do">##  $ Population: num  3615 365 2212 2110 21198 ...</span></span>
<span id="cb32-4"><a href="multiple-reg.html#cb32-4" tabindex="-1"></a><span class="do">##  $ Income    : num  3624 6315 4530 3378 5114 ...</span></span>
<span id="cb32-5"><a href="multiple-reg.html#cb32-5" tabindex="-1"></a><span class="do">##  $ Illiteracy: num  2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ...</span></span>
<span id="cb32-6"><a href="multiple-reg.html#cb32-6" tabindex="-1"></a><span class="do">##  $ Life_Exp  : num  69 69.3 70.5 70.7 71.7 ...</span></span>
<span id="cb32-7"><a href="multiple-reg.html#cb32-7" tabindex="-1"></a><span class="do">##  $ HS_Grad   : num  41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ...</span></span>
<span id="cb32-8"><a href="multiple-reg.html#cb32-8" tabindex="-1"></a><span class="do">##  $ Frost     : num  20 152 15 65 20 166 139 103 11 60 ...</span></span>
<span id="cb32-9"><a href="multiple-reg.html#cb32-9" tabindex="-1"></a><span class="do">##  $ Area      : num  50708 566432 113417 51945 156361 ...</span></span>
<span id="cb32-10"><a href="multiple-reg.html#cb32-10" tabindex="-1"></a><span class="do">##  $ Murder    : num  15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ...</span></span></code></pre></div>
<p>다중회귀모형에 의한 분석을 진행하기 전에 반드시 거쳐야 할 단계가 있는데, 그것은 모형에 포함될 변수들의 관계를 탐색하는 것이다.
변수들 사이의 관계 탐색에 많이 사용되는 방법은 상관계수와 산점도행렬이다.
산점도행렬과 같은 그래프에 의한 탐색은 필수적이라 할 수 있으며, 연속형 변수의 경우에는 두 변수끼리 짝을 지어 상관계수를 살펴보는 것도 필요하다.</p>
<p>상관계수는 변수들 사이의 선형관계 정도를 확인할 때 사용할 수 있는데, 함수 <code>cor()</code>로 계산할 수 있다.
사용법은 다음과 같다.</p>
<p><code>cor(x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman"))</code></p>
<p><code>x</code>와 <code>y</code> 모두 벡터, 행렬 혹은 데이터 프레임이 가능한데, <code>x</code>만 주어지면 <code>x</code>에 포함된 모든 변수들 사이의 상관계수를 계산하게 되고, <code>y</code>도 주어지면 <code>x</code>에 속한 변수와 <code>y</code>에 속한 변수들을 하나씩 짝을 지어 상관계수를 계산하게 된다.</p>
<p><code>use</code>는 결측값의 처리방식에 대한 것으로 선택할 수 있는 것은 디폴트인 <code>"everything"</code>과 <code>"all.obs"</code>, <code>"complete.obs"</code>, <code>"pairwise.complete.obs"</code>이 있으며, 해당 문자의 약칭으로도 사용이 가능하다.
결측값이 존재하면 <code>use = "everything"</code>인 경우에는 <code>NA</code>가 계산결과로 출력되고, <code>use = "all"</code>인 경우에는 오류가 발생한다.
또한 <code>use = "complete"</code>의 경우에는 <code>NA</code>가 있는 행은 모두 제거된 상태에서 상관계수가 계산되고, <code>use = "pairwise"</code>의 경우에는 상관계수가 계산되는 변수들만을 대상으로 <code>NA</code>가 있는 행을 제거하고 상관계수를 계산한다.</p>
<p><code>method</code>는 계산하는 상관계수의 종류를 선택한다. 디폴트인 <code>"pearson"</code>은 Pearson의 상관계수를 지정하는 것으로 두 변수 사이의 선형관계 정도를 표현하는 가장 일반적으로 많이 사용되는 상관계수를 계산한다.
두 번째 방법인 <code>"kendall"</code>은 Kendall의 순위상관계수 혹은 Kendall의 <span class="math inline">\(\tau\)</span> 를 지정하는 것으로서 concordant pair와 discordant pair를 이용하여 정의되는 비모수 상관계수를 계산하며, 순서형 자료에 주로 적용되는 방법이다.
세 번째 방법인 <code>"spearman"</code>은 Spearman의 순위상관계수 혹은 Spearman의 <span class="math inline">\(\rho\)</span> 를 지정하는 것으로서 두 변수 사이의 관계가 단조증가 혹은 단조감소 함수로 얼마나 잘 설명될 수 있는지를 표현하는 비모수 상관계수를 계산한다.
정규성 가정이 어긋나는 경우에 사용할 수 있다.</p>
<p>데이터 프레임 <code>states</code>를 구성하고 있는 변수들의 상관계수를 구해보자.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="multiple-reg.html#cb33-1" tabindex="-1"></a><span class="fu">cor</span>(states)</span>
<span id="cb33-2"><a href="multiple-reg.html#cb33-2" tabindex="-1"></a><span class="do">##             Population     Income  Illiteracy    Life_Exp     HS_Grad</span></span>
<span id="cb33-3"><a href="multiple-reg.html#cb33-3" tabindex="-1"></a><span class="do">## Population  1.00000000  0.2082276  0.10762237 -0.06805195 -0.09848975</span></span>
<span id="cb33-4"><a href="multiple-reg.html#cb33-4" tabindex="-1"></a><span class="do">## Income      0.20822756  1.0000000 -0.43707519  0.34025534  0.61993232</span></span>
<span id="cb33-5"><a href="multiple-reg.html#cb33-5" tabindex="-1"></a><span class="do">## Illiteracy  0.10762237 -0.4370752  1.00000000 -0.58847793 -0.65718861</span></span>
<span id="cb33-6"><a href="multiple-reg.html#cb33-6" tabindex="-1"></a><span class="do">## Life_Exp   -0.06805195  0.3402553 -0.58847793  1.00000000  0.58221620</span></span>
<span id="cb33-7"><a href="multiple-reg.html#cb33-7" tabindex="-1"></a><span class="do">## HS_Grad    -0.09848975  0.6199323 -0.65718861  0.58221620  1.00000000</span></span>
<span id="cb33-8"><a href="multiple-reg.html#cb33-8" tabindex="-1"></a><span class="do">## Frost      -0.33215245  0.2262822 -0.67194697  0.26206801  0.36677970</span></span>
<span id="cb33-9"><a href="multiple-reg.html#cb33-9" tabindex="-1"></a><span class="do">## Area        0.02254384  0.3633154  0.07726113 -0.10733194  0.33354187</span></span>
<span id="cb33-10"><a href="multiple-reg.html#cb33-10" tabindex="-1"></a><span class="do">## Murder      0.34364275 -0.2300776  0.70297520 -0.78084575 -0.48797102</span></span>
<span id="cb33-11"><a href="multiple-reg.html#cb33-11" tabindex="-1"></a><span class="do">##                 Frost        Area     Murder</span></span>
<span id="cb33-12"><a href="multiple-reg.html#cb33-12" tabindex="-1"></a><span class="do">## Population -0.3321525  0.02254384  0.3436428</span></span>
<span id="cb33-13"><a href="multiple-reg.html#cb33-13" tabindex="-1"></a><span class="do">## Income      0.2262822  0.36331544 -0.2300776</span></span>
<span id="cb33-14"><a href="multiple-reg.html#cb33-14" tabindex="-1"></a><span class="do">## Illiteracy -0.6719470  0.07726113  0.7029752</span></span>
<span id="cb33-15"><a href="multiple-reg.html#cb33-15" tabindex="-1"></a><span class="do">## Life_Exp    0.2620680 -0.10733194 -0.7808458</span></span>
<span id="cb33-16"><a href="multiple-reg.html#cb33-16" tabindex="-1"></a><span class="do">## HS_Grad     0.3667797  0.33354187 -0.4879710</span></span>
<span id="cb33-17"><a href="multiple-reg.html#cb33-17" tabindex="-1"></a><span class="do">## Frost       1.0000000  0.05922910 -0.5388834</span></span>
<span id="cb33-18"><a href="multiple-reg.html#cb33-18" tabindex="-1"></a><span class="do">## Area        0.0592291  1.00000000  0.2283902</span></span>
<span id="cb33-19"><a href="multiple-reg.html#cb33-19" tabindex="-1"></a><span class="do">## Murder     -0.5388834  0.22839021  1.0000000</span></span></code></pre></div>
<p>함수 <code>cor()</code>에 데이터 프레임을 입력하면 모든 변수들 사이의 상관계수가 행렬 형태로 계산되어 출력된다.
상관계수행렬은 변수의 개수가 많아지면 변수 사이의 관계 파악이 어려워지는 문제가 있다.
이런 경우에는 그래프로 표현하는 것이 더 효과적인 방법이 될 것이다.</p>
<p>패키지 <code>GGally</code>의 함수 <code>ggcorr()</code>은 상관계수행렬을 그래프로 표현할 때 많이 사용되는 함수이며, 사용법은 다음과 같다.</p>
<p><code>ggcorr(data, method = c("pairwise", "pearson"), label = FALSE, label_round = 1, ...)</code></p>
<p><code>method</code>는 결측값 처리 방식과 계산되는 상관계수의 종류를 차례로 지정하는데, 디폴트는 <code>"pairwise"</code>와 <code>"pearson"</code>이다.
<code>label</code>은 그래프에 상관계수를 표시할 것인지 여부를 결정하는 것이고, <code>label_round</code>는 표시되는 상관계수의 반올림 자릿수를 지정한다.</p>
<p>데이터 프레임 <code>states</code>를 구성하고 하는 변수들의 상관계수를 그래프로 나타내 보자.
숫자로만 구성되어 있는 상관계수행렬보다 훨씬 간편하게 변수 사이의 상관관계를 파악할 수 있다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="multiple-reg.html#cb34-1" tabindex="-1"></a><span class="fu">library</span>(GGally)</span>
<span id="cb34-2"><a href="multiple-reg.html#cb34-2" tabindex="-1"></a><span class="fu">ggcorr</span>(states, <span class="at">label =</span> <span class="cn">TRUE</span>, <span class="at">label_round =</span> <span class="dv">2</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:ex4-2-1"></span>
<img src="_main_files/figure-html/ex4-2-1-1.png" alt="함수 `ggcorr()`에 의한 상관계수 그래프" width="768" />
<p class="caption">
그림 4.2: 함수 <code>ggcorr()</code>에 의한 상관계수 그래프
</p>
</div>
<p>반응변수를 마지막 변수로 이동시켰기 때문에 반응변수와 다른 설명변수 사이의 상관계수를 편하게 확인할 수 있다.
반응변수 <code>Murder</code>가 설명변수 <code>Illiteracy</code>와는 비교적 높은 양의 상관관계를, <code>Life_Exp</code>와는 비교적 높은 음의 상관관계를 보이고 있다.</p>
<p>상관계수는 두 변수 사이의 선형관계 정도만을 측정하는 측도이다.
변수 사이에 존재하는 ’있는 그대로’의 관계를 확인하는 가장 좋은 방법은 산점도행렬이다.
함수 <code>GGally::ggpairs()</code>로 작성해 보자.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="multiple-reg.html#cb35-1" tabindex="-1"></a><span class="fu">ggpairs</span>(states, <span class="at">lower =</span> <span class="fu">list</span>(<span class="at">continuous =</span> <span class="st">&quot;smooth&quot;</span>))</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:ex4-2-2"></span>
<img src="_main_files/figure-html/ex4-2-2-1.png" alt="함수 `ggpairs()`에 의한 산점도행렬" width="768" />
<p class="caption">
그림 4.3: 함수 <code>ggpairs()</code>에 의한 산점도행렬
</p>
</div>
<p>반응변수를 마지막 변수로 위치를 이동시켰기 때문에 산점도행렬의 마지막 행을 이루고 있는 모든 패널에서 <code>Murder</code>가 Y축 변수로 배치되고, 설명변수들이 각각 X축 변수로 배치되었다.</p>
<p>이제 <code>states</code> 자료에 대한 회귀모형을 함수 <code>lm()</code>으로 적합해 보자.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="multiple-reg.html#cb36-1" tabindex="-1"></a>fit_s <span class="ot">&lt;-</span> <span class="fu">lm</span>(Murder <span class="sc">~</span> ., <span class="at">data =</span> states)</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="multiple-reg.html#cb37-1" tabindex="-1"></a>fit_s</span>
<span id="cb37-2"><a href="multiple-reg.html#cb37-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb37-3"><a href="multiple-reg.html#cb37-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb37-4"><a href="multiple-reg.html#cb37-4" tabindex="-1"></a><span class="do">## lm(formula = Murder ~ ., data = states)</span></span>
<span id="cb37-5"><a href="multiple-reg.html#cb37-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb37-6"><a href="multiple-reg.html#cb37-6" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb37-7"><a href="multiple-reg.html#cb37-7" tabindex="-1"></a><span class="do">## (Intercept)   Population       Income   Illiteracy     Life_Exp      HS_Grad  </span></span>
<span id="cb37-8"><a href="multiple-reg.html#cb37-8" tabindex="-1"></a><span class="do">##   1.222e+02    1.880e-04   -1.592e-04    1.373e+00   -1.655e+00    3.234e-02  </span></span>
<span id="cb37-9"><a href="multiple-reg.html#cb37-9" tabindex="-1"></a><span class="do">##       Frost         Area  </span></span>
<span id="cb37-10"><a href="multiple-reg.html#cb37-10" tabindex="-1"></a><span class="do">##  -1.288e-02    5.967e-06</span></span></code></pre></div>
<p>함수 <code>lm()</code>으로 생성된 객체 <code>fit_s</code>을 단순하게 출력시키면 추정된 회귀계수만 나타나지만, 사실 객체 <code>fit_s</code>는 많은 양의 정보가 담겨 있는 리스트이며, 이것은 획득하기 위해서는 몇 가지 함수를 사용해야 한다.
함수 목록은 아래 표에 정리되어 있으며, 사용하는 방법은 앞으로 살펴보겠다.</p>
<table>
<caption>함수 <code>lm()</code> 으로 생성된 객체에서 필요한 결과를 얻기 위해 유용하게 사용되는 함수</caption>
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead>
<tr class="header">
<th>함수</th>
<th>산출 결과</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>anova()</code></td>
<td>추정된 회귀모형의 분산분석표 혹은 두 개 이상의 추정된 모형을 비교하기 위한 분산분석표</td>
</tr>
<tr class="even">
<td><code>coefficients()</code></td>
<td>추정된 회귀계수. <code>coef()</code>도 가능.</td>
</tr>
<tr class="odd">
<td><code>confint()</code></td>
<td>회귀계수의 신뢰구간. 95% 신뢰구간이 디폴트.</td>
</tr>
<tr class="even">
<td><code>deviance()</code></td>
<td>잔차제곱합(residual sum of squares; RSS), <span class="math inline">\(\sum (y_{i}-\hat{y}_{i})^{2}\)</span></td>
</tr>
<tr class="odd">
<td><code>fitted()</code></td>
<td>반응변수의 적합값, <span class="math inline">\(\hat{y}_{i}\)</span></td>
</tr>
<tr class="even">
<td><code>residuals()</code></td>
<td>회귀모형의 잔차, <span class="math inline">\(e_{i}=y_{i}-\hat{y}_{i}\)</span> . <code>resid()</code>도 가능.</td>
</tr>
<tr class="odd">
<td><code>summary()</code></td>
<td>회귀모형의 다양한 적합 결과</td>
</tr>
</tbody>
</table>
</div>
<div id="다항회귀모형" class="section level3 hasAnchor" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> 다항회귀모형<a href="multiple-reg.html#다항회귀모형" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>에 정의된 다중회귀모형에서는 반응변수와 설명변수 사이의 관계가 선형이라고 가정하고 있다.
하지만 두 변수의 관계가 그림 <a href="ch1.html#fig:1-3">1.4</a>와 같이 명확한 2차 함수 관계가 있을 경우에는 설명변수의 제곱항을 모형에 추가하는 다항회귀모형이 더 적절한 대안이 될 수 있다.</p>
<p>단순회귀모형에 대한 <span class="math inline">\(p\)</span> 차 다항회귀모형은 다음과 같이 설정된다.</p>
<p><span class="math display" id="eq:poly-reg-1">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X + \beta_{2}X^{2} + \cdots + \beta_{p}X^{p} + \varepsilon
\tag{4.11}
\end{equation}\]</span></p>
<p>차수 <span class="math inline">\(p\)</span> 는 가능한 낮게 잡는 것이 좋은데, 그것은 너무 높은 차수의 항을 모형에 포함시키면 <span class="math inline">\(\left( \mathbf{X}^{T} \mathbf{X} \right)^{-1}\)</span> 가 불안정해질 수 있고, 따라서 회귀계수 추정에 문제가 생길 수 있기 때문이다.
이 문제는 ’다중공선성’을 소개할 때 다시 살펴보겠다.</p>
<p>일단 차수가 선택되면, 선택된 차수 이하의 모든 차수는 반드시 모형에 포함되어야 한다.
예를 들어 <span class="math inline">\(Y=\beta_{0}+\beta_{1}X+\beta_{2}X^{2}+\varepsilon\)</span> 모형에서 어떠한 이유에서 <span class="math inline">\(X\)</span> 의 1차항을 제거한다면, 모형은 <span class="math inline">\(Y=\beta_{0}+\beta_{2}X^{2}+\varepsilon\)</span> 가 되는데, 이 모형은 Y축을 중심으로 좌우대칭을 이루어야 하는 지나치게 강한 가정을 갖게 된다.
또한 만일 변수 <span class="math inline">\(X\)</span> 의 값을 <span class="math inline">\(a\)</span> 만큼 평행 이동시켜야 한다면, <span class="math inline">\(X\)</span> 가 <span class="math inline">\(X+a\)</span> 로 변경되어 다음과 같이 모형에 다시 1차항이 나타나게 된다.</p>
<p><span class="math display">\[\begin{align*}
Y &amp;= \beta_{0} + \beta_{2}(X+a)^{2} + \varepsilon \\
&amp;= \beta_{0} + \beta_{2}(X^{2} + 2aX + a^{2}) + \varepsilon
\end{align*}\]</span></p>
<p>설명변수가 <span class="math inline">\(X_{1}\)</span> 과 <span class="math inline">\(X_{2}\)</span> 인 다중회귀모형에서 두 변수가 모두 반응변수와 2차 함수 관계가 있다면, 다음과 같은 다항회귀모형이 적절한 회귀모형이 될 수 있다.</p>
<p><span class="math display" id="eq:poly-reg-2">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{2} + \beta_{3}X_{1}^{2} + \beta_{4}X_{2}^{2} + \varepsilon
\tag{4.12}
\end{equation}\]</span></p>
<p><span class="math inline">\(\bullet\)</span> 예제: <code>women</code></p>
<p>데이터 프레임 <code>women</code>에는 미국 30대 여성의 키(<code>height</code>)와 몸무게(<code>weight</code>)가 입력되어 있다.
두 변수 <code>height</code>와 <code>weight</code>의 회귀모형을 설정해 보자.
먼저 두 변수의 관계가 선형인지 여부를 그래프로 확인해 보자.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="multiple-reg.html#cb38-1" tabindex="-1"></a><span class="fu">ggplot</span>(women, <span class="fu">aes</span>(<span class="at">x =</span> height, <span class="at">y =</span> weight)) <span class="sc">+</span> </span>
<span id="cb38-2"><a href="multiple-reg.html#cb38-2" tabindex="-1"></a>   <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) <span class="sc">+</span></span>
<span id="cb38-3"><a href="multiple-reg.html#cb38-3" tabindex="-1"></a>   <span class="fu">geom_smooth</span>(<span class="fu">aes</span>(<span class="at">color =</span> <span class="st">&quot;loess&quot;</span>), <span class="at">se =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb38-4"><a href="multiple-reg.html#cb38-4" tabindex="-1"></a>   <span class="fu">geom_smooth</span>(<span class="fu">aes</span>(<span class="at">color =</span> <span class="st">&quot;linear&quot;</span>), <span class="at">method=</span><span class="st">&quot;lm&quot;</span>, <span class="at">se =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb38-5"><a href="multiple-reg.html#cb38-5" tabindex="-1"></a>   <span class="fu">labs</span>(<span class="at">color =</span> <span class="cn">NULL</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:women-1"></span>
<img src="_main_files/figure-html/women-1-1.png" alt="데이터 프레임 `women`의 변수 `height`와 `weight`의 산점도와 선형회귀직선 및 국소회귀곡선" width="576" />
<p class="caption">
그림 4.4: 데이터 프레임 <code>women</code>의 변수 <code>height</code>와 <code>weight</code>의 산점도와 선형회귀직선 및 국소회귀곡선
</p>
</div>
<p>두 변수의 관계가 선형보다는 2차 곡선이 더 적합한 것으로 보인다.</p>
<p>다항회귀모형은 함수 <code>poly()</code>를 이용하거나 또는 함수 <code>I()</code>를 이용해서 적합할 수 있다.
함수 <code>poly()</code>는 함수 <code>lm()</code>과 함께 <code>lm(y ~ poly(x, degree = 1, raw = FALSE), data)</code>와 같이 사용할 수 있다.
<code>degree</code>는 다항회귀모형의 차수를 지정하는 것으로 디폴트 값은 1차이고, <code>raw</code>는 직교다항회귀(orthogonal polynomial regression)의 사용 여부를 선택하는 것으로서 디폴트 값인 <code>FALSE</code>는 직교다항회귀에 의한 적합이 된다.
따라서 일반적인 다항회귀모형을 사용하고자 한다면 반드시 <code>raw</code>에 <code>TRUE</code>를 지정해야 한다.</p>
<p>차수가 높지 않은 일반적인 다항회귀모형을 적합하는 경우에는 함수 <code>I()</code>를 사용하는 것이 더 간편할 수 있다.
함수 <code>lm()</code> 안에서 <code>lm(y ~ x + I(x^2), data)</code>와 같이 입력하면 2차 다항회귀모형을 적합하게 된다.</p>
<p>반응변수 <code>weight</code>에 대한 설명변수 <code>height</code>의 2차 다항회귀모형을 적합해 보자.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="multiple-reg.html#cb39-1" tabindex="-1"></a>fit_w <span class="ot">&lt;-</span> <span class="fu">lm</span>(weight <span class="sc">~</span> height <span class="sc">+</span> <span class="fu">I</span>(height<span class="sc">^</span><span class="dv">2</span>), women)</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="multiple-reg.html#cb40-1" tabindex="-1"></a>fit_w</span>
<span id="cb40-2"><a href="multiple-reg.html#cb40-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb40-3"><a href="multiple-reg.html#cb40-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb40-4"><a href="multiple-reg.html#cb40-4" tabindex="-1"></a><span class="do">## lm(formula = weight ~ height + I(height^2), data = women)</span></span>
<span id="cb40-5"><a href="multiple-reg.html#cb40-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb40-6"><a href="multiple-reg.html#cb40-6" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb40-7"><a href="multiple-reg.html#cb40-7" tabindex="-1"></a><span class="do">## (Intercept)       height  I(height^2)  </span></span>
<span id="cb40-8"><a href="multiple-reg.html#cb40-8" tabindex="-1"></a><span class="do">##   261.87818     -7.34832      0.08306</span></span></code></pre></div>
<p>적합된 회귀모형식은 <span class="math inline">\(\hat{y}_{i}=261.87 - 7.348x_{i} + 0.08x_{i}^{2}\)</span> 임을 알 수 있다.</p>
</div>
<div id="section-dummy" class="section level3 hasAnchor" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> 가변수 회귀모형<a href="multiple-reg.html#section-dummy" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>선형회귀모형에서 반응변수는 유형이 반드시 연속형이어야 하며, 정규분포의 가정이 필요하다. 반면에 설명변수는 연속형 변수와 범주형 변수가 모두 가능한데, 연속형인 경우에는 정규분포의 가정은 필요 없으나 가능한 좌우대칭에 가까운 분포를 하는 것이 좋다. 범주형 변수 중 순서형 변수인 경우에는 연속형 변수처럼 변수의 값을 그대로 사용하는 것이 가능하지만, 명목형 변수의 경우에는 변수의 값을 그대로 사용하면 절대로 안 되고, 반드시 가변수(dummy variable)를 대신 사용해야 한다.</p>
<p>가변수를 설정하는 방식은 몇 가지가 있는데, 그 중 회귀계수 <span class="math inline">\(\beta_{0}\)</span> 를 유지하는 방식을 살펴보자. 이 경우, 가변수는 0 또는 1의 값을 갖게 되며, 범주의 개수보다 하나 작은 개수의 가변수를 사용하게 된다. 예를 들어, “Yes”, “No”와 같은 2개의 범주를 갖는 범주형 변수와 연속형 변수 <span class="math inline">\(X\)</span> 를 설명변수로 하는 회귀모형은 다음과 같이 하나의 가변수를 갖게 된다.</p>
<p><span class="math display" id="eq:dummy-1">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X + \beta_{2}D + \varepsilon
\tag{4.13}
\end{equation}\]</span></p>
<p>가변수 <span class="math inline">\(D\)</span> 가 “Yes” 범주이면 1, “No” 범주이면 0을 값으로 갖는다면, 모집단 회귀직선은 다음과 같이 주어진다.
<span class="math display">\[
E(Y) =
\begin{cases}
\beta_{0} + \beta_{1}X &amp; \quad  \text{if   } ~~D = 0 \\
\beta_{0} + \beta_{2} + \beta_{1}X &amp; \quad  \text{if   } ~~D = 1
\end{cases}
\]</span></p>
<p><span class="math inline">\(D=0\)</span> 이 되는 범주를 ’기준범주’라고 하는데, 절편 <span class="math inline">\(\beta_{0}\)</span> 가 기준범주의 효과를 나타내고 있고, 가변수의 회귀계수 <span class="math inline">\(\beta_{2}\)</span> 는 기준범주와 “Yes” 범주의 효과 차이를 나타내고 있다.</p>
<p>식 <a href="multiple-reg.html#eq:dummy-1">(4.13)</a>의 회귀모형에서는 반응변수 <span class="math inline">\(Y\)</span> 와 설병변수 <span class="math inline">\(X\)</span> 가 “Yes”와 “No” 범주에서 동일한 관계를 갖고 있다고 가정하고 있는데, 만일 각 범주에서 두 변수의 관계가 다를 수 있다면 기울기도 다르게 설정할 필요가 있다.
만일 기울기가 그룹별로 다르다고 가정한다면 가변수와 다른 설명변수의 상호작용 효과를 추가해야 한다.
식 <a href="multiple-reg.html#eq:dummy-1">(4.13)</a>의 회귀모형에 가변수와 연속형 변수의 상호작용 효과가 추가된 모형은 다음과 같이 표현된다.</p>
<p><span class="math display" id="eq:dummy-2">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X + \beta_{2}D + \beta_{3}DX + \varepsilon
\tag{4.14}
\end{equation}\]</span></p>
<p>이 경우에 모집단 회귀직선은 다음과 같다.</p>
<p><span class="math display">\[
E(Y) =
\begin{cases}
\beta_{0} + \beta_{1}X &amp; \quad  \text{if   } ~~D = 0 \\
(\beta_{0} + \beta_{2}) + (\beta_{1}+\beta_{3})X &amp; \quad  \text{if   } ~~D = 1
\end{cases}
\]</span></p>
<p>연속형 설명변수와 가변수의 상호작용 효과를 모형에 추가하는 것이 더 포괄적인 모형을 구축하는 방법이지만, 설명변수가 많은 경우에는 지나치게 많은 변수가 모형에 추가될 수 있어서 분석에 큰 부담이 될 수 있다.
반드시 필요한 상호작용 효과를 선별해서 추가하는 것이 바람직하다.</p>
<p>범주형 변수가 3개의 범주를 갖는 경우에는 2개의 가변수가 필요하게 된다.
예를 들어 “high”, “medium”, “low”의 3가지 범주를 갖는 범주형 변수와 연속형 변수 <span class="math inline">\(X\)</span> 를 설명변수로 하는 회귀모형은 다음과 같은 형태를 갖게 된다.
반응변수 <span class="math inline">\(Y\)</span> 와 설병변수 <span class="math inline">\(X\)</span> 가 세 범주에 동일한 관계를 갖고 있다고 가정하자.</p>
<p><span class="math display">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X + \beta_{2}D_{1} + \beta_{3}D_{2} + \varepsilon
\end{equation}\]</span></p>
<p>단, <span class="math inline">\(D_{1}\)</span> 은 범주가 “high”이면 1, 아니면 0이고, <span class="math inline">\(D_{2}\)</span> 는 범주가 “medium”이면 1, 아니면 0이 되는 가변수이다. 이 경우, 기준범주는 “low”가 되며, <span class="math inline">\(\beta_{2}\)</span> 는 기준범주와 “high” 범주의 효과 차이를, <span class="math inline">\(\beta_{3}\)</span> 은 기준범주와 “medium” 범주의 효과 차이를 나타내고 있다.</p>
<p><span class="math inline">\(\bullet\)</span> 예제: <code>mtcars</code></p>
<p>반응변수는 자동차 연비인 <code>mpg</code>로 하고, 설명변수로는 1/4 마일 도착 시간인 <code>qsec</code>, 변속기 종류를 나타내는 <code>am</code>과 실린더 개수를 나타내는 <code>cyl</code>을 사용하자.</p>
<p>변수 <code>am</code>과 <code>cyl</code>은 범주형 변수이지만 숫자로 입력된 상태이다.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="multiple-reg.html#cb41-1" tabindex="-1"></a><span class="fu">str</span>(mtcars)</span>
<span id="cb41-2"><a href="multiple-reg.html#cb41-2" tabindex="-1"></a><span class="do">## &#39;data.frame&#39;:    32 obs. of  11 variables:</span></span>
<span id="cb41-3"><a href="multiple-reg.html#cb41-3" tabindex="-1"></a><span class="do">##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...</span></span>
<span id="cb41-4"><a href="multiple-reg.html#cb41-4" tabindex="-1"></a><span class="do">##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...</span></span>
<span id="cb41-5"><a href="multiple-reg.html#cb41-5" tabindex="-1"></a><span class="do">##  $ disp: num  160 160 108 258 360 ...</span></span>
<span id="cb41-6"><a href="multiple-reg.html#cb41-6" tabindex="-1"></a><span class="do">##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...</span></span>
<span id="cb41-7"><a href="multiple-reg.html#cb41-7" tabindex="-1"></a><span class="do">##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...</span></span>
<span id="cb41-8"><a href="multiple-reg.html#cb41-8" tabindex="-1"></a><span class="do">##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...</span></span>
<span id="cb41-9"><a href="multiple-reg.html#cb41-9" tabindex="-1"></a><span class="do">##  $ qsec: num  16.5 17 18.6 19.4 17 ...</span></span>
<span id="cb41-10"><a href="multiple-reg.html#cb41-10" tabindex="-1"></a><span class="do">##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...</span></span>
<span id="cb41-11"><a href="multiple-reg.html#cb41-11" tabindex="-1"></a><span class="do">##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...</span></span>
<span id="cb41-12"><a href="multiple-reg.html#cb41-12" tabindex="-1"></a><span class="do">##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...</span></span>
<span id="cb41-13"><a href="multiple-reg.html#cb41-13" tabindex="-1"></a><span class="do">##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...</span></span></code></pre></div>
<p>함수 <code>lm()</code>은 요인으로 설명변수를 입력하면 자동으로 필요한 개수의 가변수를 생성한다.
따라서 변수 <code>am</code>과 <code>cyl</code>은 요인으로 유형을 변경하는 것이 필요하다.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="multiple-reg.html#cb42-1" tabindex="-1"></a>mtcars_3 <span class="ot">&lt;-</span> mtcars <span class="sc">|&gt;</span> </span>
<span id="cb42-2"><a href="multiple-reg.html#cb42-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">am =</span> <span class="fu">factor</span>(am), <span class="at">cyl =</span> <span class="fu">factor</span>(cyl))</span></code></pre></div>
<p>요인으로 변경된 두 변수의 범주별 도수를 확인해 보자.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="multiple-reg.html#cb43-1" tabindex="-1"></a>mtcars_3 <span class="sc">|&gt;</span> <span class="fu">count</span>(am)</span>
<span id="cb43-2"><a href="multiple-reg.html#cb43-2" tabindex="-1"></a><span class="do">##   am  n</span></span>
<span id="cb43-3"><a href="multiple-reg.html#cb43-3" tabindex="-1"></a><span class="do">## 1  0 19</span></span>
<span id="cb43-4"><a href="multiple-reg.html#cb43-4" tabindex="-1"></a><span class="do">## 2  1 13</span></span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="multiple-reg.html#cb44-1" tabindex="-1"></a>mtcars_3 <span class="sc">|&gt;</span> <span class="fu">count</span>(cyl)</span>
<span id="cb44-2"><a href="multiple-reg.html#cb44-2" tabindex="-1"></a><span class="do">##   cyl  n</span></span>
<span id="cb44-3"><a href="multiple-reg.html#cb44-3" tabindex="-1"></a><span class="do">## 1   4 11</span></span>
<span id="cb44-4"><a href="multiple-reg.html#cb44-4" tabindex="-1"></a><span class="do">## 2   6  7</span></span>
<span id="cb44-5"><a href="multiple-reg.html#cb44-5" tabindex="-1"></a><span class="do">## 3   8 14</span></span></code></pre></div>
<p>두 개의 범주를 갖고 있는 <code>am</code>과 숫자형 변수 <code>qsec</code>을 설명변수로 하는 회귀모형을 적합해 보자.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="multiple-reg.html#cb45-1" tabindex="-1"></a>fit_m1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> qsec <span class="sc">+</span> am, <span class="at">data =</span> mtcars_3)</span></code></pre></div>
<p>적합 결과는 다음과 같다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="multiple-reg.html#cb46-1" tabindex="-1"></a>fit_m1</span>
<span id="cb46-2"><a href="multiple-reg.html#cb46-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb46-3"><a href="multiple-reg.html#cb46-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb46-4"><a href="multiple-reg.html#cb46-4" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ qsec + am, data = mtcars_3)</span></span>
<span id="cb46-5"><a href="multiple-reg.html#cb46-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb46-6"><a href="multiple-reg.html#cb46-6" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb46-7"><a href="multiple-reg.html#cb46-7" tabindex="-1"></a><span class="do">## (Intercept)         qsec          am1  </span></span>
<span id="cb46-8"><a href="multiple-reg.html#cb46-8" tabindex="-1"></a><span class="do">##     -18.889        1.982        8.876</span></span></code></pre></div>
<p>적합된 회귀모형을 그래프로 표현하면 그림 <a href="multiple-reg.html#fig:ex4-4-1">4.5</a>과 같이 두 개의 평행한 회귀직선으로 표현된다.</p>
<div class="figure"><span style="display:block;" id="fig:ex4-4-1"></span>
<img src="_main_files/figure-html/ex4-4-1-1.png" alt="모형 `fit_m1`의 적합 결과" width="576" />
<p class="caption">
그림 4.5: 모형 <code>fit_m1</code>의 적합 결과
</p>
</div>
<p>변수 <code>am</code>의 두 범주 중 기준 범주는 <code>am = 0</code>인 범주이며, 모형 <code>fit_m1</code>에서 사용된 가변수 <code>am1</code>은 두 범주의 효과 차이를 나타내고 있는데, 회귀계수가 8.876으로 계산된 것은 <code>am = 0</code> 범주보다 <code>am = 1</code> 범주에서 반응변수의 평균이 8.876 높다고 추정된 것이다.</p>
<p>또한 적합된 두 직선이 평행한 것은 변수 <code>qsec</code>와 <code>mpg</code>의 관계가 <code>am = 0</code> 범주와 <code>am = 1</code> 범주에서 동일하다고 가정했기 때문이다.
동일한 관계를 유지한다는 가정을 하지 않은 상태에서 회귀모형을 적합한 결과는 그림 <a href="multiple-reg.html#fig:ex4-4-2">4.6</a>와 같다.
어떤 모형을 사용하는 것이 더 적절하다고 생각하는가?
이 문제는 회귀모형의 추론을 통해 결정해야 하는 문제가 된다.</p>
<p>그림 <a href="multiple-reg.html#fig:ex4-4-2">4.6</a>에 표시된 회귀모형에는 변수 <code>qsec</code>과 <code>am</code>의 상호작용 항이 포함되었으며, 자세한 설명은 <a href="multiple-reg.html#section-multi-infer">4.2</a>절에서 살펴보겠다.</p>
<div class="figure"><span style="display:block;" id="fig:ex4-4-2"></span>
<img src="_main_files/figure-html/ex4-4-2-1.png" alt="변수 `qsec`과 `am`의 상호작용 항이 포함된 회귀모형의 적합 결과" width="576" />
<p class="caption">
그림 4.6: 변수 <code>qsec</code>과 <code>am</code>의 상호작용 항이 포함된 회귀모형의 적합 결과
</p>
</div>
<p>이번에는 세 개의 범주를 갖고 있는 <code>cyl</code>과 숫자형 변수 <code>qsec</code>을 설명변수로 하는 회귀모형을 적합해 보자.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="multiple-reg.html#cb47-1" tabindex="-1"></a>fit_m2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> qsec <span class="sc">+</span> cyl, <span class="at">data =</span> mtcars_3)</span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="multiple-reg.html#cb48-1" tabindex="-1"></a>fit_m2</span>
<span id="cb48-2"><a href="multiple-reg.html#cb48-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb48-3"><a href="multiple-reg.html#cb48-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb48-4"><a href="multiple-reg.html#cb48-4" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ qsec + cyl, data = mtcars_3)</span></span>
<span id="cb48-5"><a href="multiple-reg.html#cb48-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb48-6"><a href="multiple-reg.html#cb48-6" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb48-7"><a href="multiple-reg.html#cb48-7" tabindex="-1"></a><span class="do">## (Intercept)         qsec         cyl6         cyl8  </span></span>
<span id="cb48-8"><a href="multiple-reg.html#cb48-8" tabindex="-1"></a><span class="do">##     35.0724      -0.4394      -7.4305     -12.6029</span></span></code></pre></div>
<p>적합된 모형은 다음과 같이 그래프로 표현된다.</p>
<div class="figure"><span style="display:block;" id="fig:ex4-4-3"></span>
<img src="_main_files/figure-html/ex4-4-3-1.png" alt="모형 `fit_m2`의 적합 결과" width="576" />
<p class="caption">
그림 4.7: 모형 <code>fit_m2</code>의 적합 결과
</p>
</div>
<p>회귀모형 <code>fit_m2</code>에서 <code>cyl</code>의 기준범주는 <code>cyl = 4</code>인 범주이며, 회귀계수의 추정 결과로 기준범주에서 반응변수의 평균이 <code>cyl = 6</code>인 범주보다 7.43 높고, <code>cyl = 8</code>인 범주보다 12.6 높음을 알 수 있다.</p>
</div>
</div>
<div id="section-multi-infer" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> 다중회귀모형의 추론<a href="multiple-reg.html#section-multi-infer" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><a href="multiple-reg.html#section-multi-model">4.1</a>절에서 우리는 다항회귀모형과 가변수 회귀모형 등 몇 가지 형태의 다중회귀모형을 살펴보았고, 최소제곱추정량에 의한 회귀계수의 추정 방법도 살펴보았다.
지금부터는 회귀계수의 추론에 대해 살펴보도록 하자.
반응변수와 설명변수에 대해 자료가 관측되면 회귀모형에 대한 다양한 추론을 할 수 있는데, 이러한 추론을 진행하기 위해서는 회귀계수의 추정량에 대한 표본분포를 알아야 한다.</p>
<div id="회귀계수-추정량의-표본분포" class="section level3 hasAnchor" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> 회귀계수 추정량의 표본분포<a href="multiple-reg.html#회귀계수-추정량의-표본분포" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>다중회귀모형은 다음과 같이 행렬의 형태로 나타내는 것이 일반적인 표현 방식이 된다.</p>
<p><span class="math display">\[\begin{equation}
\mathbf{Y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}
\end{equation}\]</span></p>
<p>반응변수 벡터 <span class="math inline">\(\mathbf{Y}\)</span> 와 설명변수 관찰값 행렬 <span class="math inline">\(\mathbf{X}\)</span>, 모수 벡터 <span class="math inline">\(\boldsymbol{\beta}\)</span>, 오차항 벡터 <span class="math inline">\(\boldsymbol{\varepsilon}\)</span> 의 정의는 식 <a href="multiple-reg.html#eq:reg-matrix-1">(4.2)</a> 에서 볼 수 있다.
또한 오차항 <span class="math inline">\(\varepsilon_{i}, ~i=1,\ldots,n\)</span> 이 모두 평균이 <span class="math inline">\(0\)</span>, 분산이 <span class="math inline">\(\sigma^{2}\)</span> 이며, 서로 독립이라는 가정도 다음과 같이 행렬로 표현할 수 있다.</p>
<p><span class="math display">\[
E(\boldsymbol{\varepsilon}) =
\begin{pmatrix}
0 \\ 0 \\ \vdots \\ 0
\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
Var(\boldsymbol{\varepsilon}) =
\begin{pmatrix}
\sigma^{2} &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; \sigma^{2} &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; \sigma^{2}
\end{pmatrix}=
\sigma^{2}~\mathbf{I}
\]</span></p>
<p>단, <span class="math inline">\(\mathbf{I}\)</span> 는 <span class="math inline">\(n\)</span> 차 단위행렬이다.</p>
<p>오차항 벡터의 가정을 기반으로 반응변수 벡터 <span class="math inline">\(\mathbf{Y}\)</span> 의 평균과 분산은 다음과 같이 구할 수 있으며,</p>
<p><span class="math display">\[\begin{equation}
E(\mathbf{Y}) = E(\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}) = E(\mathbf{X}\boldsymbol{\beta}) = \mathbf{X}\boldsymbol{\beta}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
Var(\mathbf{Y}) = Var(\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}) = Var(\boldsymbol{\varepsilon}) = \sigma^{2}~\mathbf{I}
\end{equation}\]</span></p>
<p>오차항이 정규분포한다는 가정을 추가하면 반응변수 벡터 <span class="math inline">\(\mathbf{Y}\)</span> 의 분포는 다음과 같다.</p>
<p><span class="math display">\[\begin{equation}
\mathbf{Y} \sim N(\boldsymbol{\beta},~\sigma^{2}\mathbf{I})
\end{equation}\]</span></p>
<p>이제 모수 벡터 <span class="math inline">\(\boldsymbol{\beta}\)</span> 의 최소제곱추정량 <span class="math inline">\(\hat{\boldsymbol{\beta}} = (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{Y}\)</span> 의 표본분포를 알아보자.
먼저 추정량 벡터의 평균은 다음과 같이 구할 수 있다.</p>
<p><span class="math display">\[\begin{align*}
E(\hat{\boldsymbol{\beta}}) &amp;= E((\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{Y}) \\
&amp;= (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}E(\mathbf{Y}) \\
&amp;= (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{X}\boldsymbol{\beta} \\
&amp;= \boldsymbol{\beta}
\end{align*}\]</span></p>
<p>추정량 벡터의 분산은 다음과 같이 구할 수 있다.</p>
<p><span class="math display">\[\begin{align*}
Var(\hat{\boldsymbol{\beta}})
&amp;= Var((\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{Y}) \\
&amp;= (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}~Var(\mathbf{Y})~ ((\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T})^{T} \\
&amp;= (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T}~\sigma^{2}\mathbf{I}~ ((\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T})^{T} \\
&amp;= \sigma^{2} (\mathbf{X}^{T}\mathbf{X})^{-1}\mathbf{X}^{T} \mathbf{X} (\mathbf{X}^{T}\mathbf{X})^{-1} \\
&amp;= \sigma^{2} (\mathbf{X}^{T}\mathbf{X})^{-1}
\end{align*}\]</span></p>
<p>또한 <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> 은 반응변수 벡터 <span class="math inline">\(\mathbf{Y}\)</span> 의 선형결합으로 표시되기 때문에 <span class="math inline">\(\mathbf{Y}\)</span> 와 같은 정규분포를 하게 된다. 따라서 추정량 벡터의 표본분포는 다음과 같이 주어진다.</p>
<p><span class="math display" id="eq:multi-dist-lse-1">\[\begin{equation}
\hat{\boldsymbol{\beta}} \sim N\left(\boldsymbol{\beta},~\sigma^{2} (\mathbf{X}^{T}\mathbf{X})^{-1}\right)
\tag{4.15}
\end{equation}\]</span></p>
<p>또한 개별 추정량의 분포는 다음과 같이 주어진다.</p>
<p><span class="math display" id="eq:multi-dist-lse-2">\[\begin{equation}
\hat{\beta}_{j} \sim N(\beta_{j},~c_{j+1,j+1}~\sigma^{2}),~~j=0,1,\ldots,k
\tag{4.16}
\end{equation}\]</span>
단, <span class="math inline">\(c_{i, j}\)</span>은 <span class="math inline">\((\mathbf{X}^{T}\mathbf{X})^{-1}\)</span> 행렬의 <span class="math inline">\(i\)</span> 번째 행, <span class="math inline">\(j\)</span> 번째 열 원소를 나타낸다.</p>
<p>식 <a href="multiple-reg.html#eq:multi-dist-lse-1">(4.15)</a>에 주어진 추정량 벡터의 표본분포를 이용해서 추론을 실시하기 위해서는 오차항 분산인 <span class="math inline">\(\sigma^{2}\)</span> 에 대한 추정값이 반드시 필요하다.
<a href="simple-reg.html#section-simple-sigma">2.3</a>절에서 단순회귀모형의 경우에 적용되는 오차항 분산의 추정량 <span class="math inline">\(MSE\)</span> 가 식 <a href="simple-reg.html#eq:mse-1">(2.17)</a>으로 유도되는 것을 살펴보았다.
단순회귀모형의 경우 잔차제곱합 <span class="math inline">\(RSS\)</span>의 자유도가 <span class="math inline">\((n-2)\)</span> 가 된 이유는 <span class="math inline">\(\widehat{Y}_{i}\)</span> 을 얻기 위해 추정해야할 모수의 개수가 2개이기 때문이다.
다중회귀모형에서는 추정해야 할 모수가 <span class="math inline">\(\beta_{0}, \beta_{1}, \ldots, \beta_{k}\)</span> 의 <span class="math inline">\((k+1)\)</span> 개가 있고, 따라서 <span class="math inline">\(RSS\)</span>의 자유도는 <span class="math inline">\((n-k-1)\)</span> 이 되어서 <span class="math inline">\(\sigma^{2}\)</span> 의 불편추정량 <span class="math inline">\(MSE\)</span> 는 다음과 같이 주어진다.</p>
<p><span class="math display" id="eq:multi-mse-1">\[\begin{equation}
\hat{\sigma}^{2} = \frac{RSS}{n-k-1} = MSE
\tag{4.17}
\end{equation}\]</span></p>
<p>식 <a href="multiple-reg.html#eq:multi-mse-1">(4.17)</a>의 <span class="math inline">\(MSE\)</span> 는 <span class="math inline">\(k=1\)</span> 인 단순회귀모형의 경우도 포괄하는 일반적인 정의가 된다.</p>
</div>
<div id="section-multi-model-signif" class="section level3 hasAnchor" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> 회귀모형의 유의성 검정<a href="multiple-reg.html#section-multi-model-signif" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>의 회귀모형을 반응변수의 변동을 설명할 수 있을 것으로 생각한 모든 설명변수로 구성한 첫 번째 모형이라고 해 보자.
그러면 우리가 가장 먼저 실행할 수 있는 검정은 식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>의 회귀모형에 포함된 설명변수 중 반응변수의 변동을 설명하는데 유의적인 변수가 적어도 하나라도 있는지 알아보는 것이 될 것이며, 이것을 회귀모형의 유의성 검정이라고 한다.</p>
<p>귀무가설은 다음과 같고,</p>
<p><span class="math display" id="eq:H0-1">\[\begin{equation}
H_{0}:\beta_{1}=\beta_{2}=\cdots=\beta_{k}=0
\tag{4.18}
\end{equation}\]</span></p>
<p>대립가설은 다음과 같다.</p>
<p><span class="math display">\[\begin{equation}
H_{1}: \text{at least one of }\beta_{j} \ne 0
\end{equation}\]</span></p>
<p>가설에 대한 검정통계량은 다음과 같다.</p>
<p><span class="math display">\[\begin{equation}
F = \frac{(TSS-RSS)/k}{RSS/(n-k-1)}
\end{equation}\]</span></p>
<p>귀무가설이 사실일 때 검정통게량의 분포는 <span class="math inline">\(F_{k,~n-k-1}\)</span> 이다.</p>
<p>검정통계량의 구성을 살펴보자.
<span class="math inline">\(TSS=\sum(y_{i}-\overline{y})^{2}\)</span> 는 반응변수의 총변량으로서 설명변수와는 관련이 없는 변량이다.
<span class="math inline">\(RSS = \sum(y_{i}-\hat{y}_{i})^{2}\)</span> 는 잔차제곱합으로서 <span class="math inline">\(y_{i}\)</span> 를 <span class="math inline">\(\hat{y}_{i}\)</span> 으로 예측함으로써 발생한 오차이며, 회귀모형으로 설명이 안 된 변량이라고 할 수 있다.
따라서 총변량에서 설명이 안 된 변량을 제외한 <span class="math inline">\((TSS-RSS)\)</span> 는 회귀모형으로 설명된 변량이라고 할 수 있다.
따라서 검정통계량은 회귀모형에 의해서 설명이 가능한 변량과 설명이 안 되는 변량의 상대적 크기라고 할 수 있으며,
검정통계량의 값이 충분히 크다면 회귀모형으로 반응변수의 변량을 설명할 수 있다는 것을 의미하기 때문에 귀무가설을 기각할 수 있게 된다.</p>
<p>검정통계량의 분모와 분자의 특성을 조금 더 자세하게 살펴보자.
검정통계량의 분모는 <span class="math inline">\(RSS\)</span>를 자신의 자유도 <span class="math inline">\((n-k-1)\)</span> 로 나눈 것으로서, 이 통계량은 회귀모형의 가정이 만족이 되면 귀무가설의 사실 여부와 관계 없이 오차항의 분산인 <span class="math inline">\(\sigma^{2}\)</span>의 불편추정량이 된다.
즉, 가설의 사실 여부와 관계 없이 다음은 성립된다.</p>
<p><span class="math display" id="eq:e-rss">\[\begin{equation}
E(RSS/(n-k-1))=\sigma^{2}
\tag{4.19}
\end{equation}\]</span></p>
<p>이것은 <span class="math inline">\(RSS/\sigma^{2}\)</span> 이 자유도가 <span class="math inline">\((n-k-1)\)</span> 인 <span class="math inline">\(\chi^{2}\)</span> 분포를 하기 때문에 성립된다.</p>
<p>반면에, 검정통계량의 분자는 <span class="math inline">\((TSS-RSS)\)</span> 을 자신의 자유도인 <span class="math inline">\(k\)</span> 로 나눈 것으로서, 이 통계량은 <span class="math inline">\(H_{0}\)</span> 이 사실인 경우에는 <span class="math inline">\(\sigma^{2}\)</span> 의 불편추정량이 되는데, 이것은 <span class="math inline">\(H_{0}\)</span>이 사실인 경우에 <span class="math inline">\((TSS-RSS)/\sigma^{2}\)</span> 이 자유도가 <span class="math inline">\(k\)</span> 인 <span class="math inline">\(\chi^{2}\)</span> 분포를 하기 때문이다.
그러나 <span class="math inline">\(H_{0}\)</span> 이 사실이 아닌 경우에는 <span class="math inline">\(\sigma^{2}\)</span> 을 과대 추정하는 특성이 있다.
따라서 <span class="math inline">\(H_{0}\)</span>이 사실이 아니면 다음과 같이 된다.</p>
<p><span class="math display" id="eq:e-tss-rss">\[\begin{equation}
E((TSS-RSS)/k) &gt; \sigma^{2}
\tag{4.20}
\end{equation}\]</span></p>
<p>식 <a href="multiple-reg.html#eq:e-rss">(4.19)</a>와 식 <a href="multiple-reg.html#eq:e-tss-rss">(4.20)</a>에 의해서 만일 검정통계량이 1보다 상당히 큰 값이 되면 <span class="math inline">\(H_{0}\)</span>이 사실이 아닐 가능성이 높게 되는 것을 알 수 있다.
<span class="math inline">\(H_{0}\)</span>이 사실인 경우 검정통계량은 <span class="math inline">\(\chi^{2}\)</span> 분포를 하는 두 통계량의 비율이 되기 때문에 <span class="math inline">\(F\)</span> 분포를 하게 되며, 자유도는 <span class="math inline">\((k, ~n-k-1)\)</span> 를 갖게 된다.</p>
<p>가설 <a href="multiple-reg.html#eq:H0-1">(4.18)</a>이 기각되면 모형에 포함된 설명변수 중 유의한 변수가 있다는 것이므로, 개별 회귀계수에 대한 유의성 검정을 진행할 수 있다.
그러나 만일 가설을 기각할 수 없다면 식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>의 회귀모형으로는 반응변수의 변동을 제대로 설명할 수 없다는 것이 된다.
이런 결과가 나오면, 다른 설명변수의 조합을 찾아 보거나, 또는 다른 형태의 회귀모형을 시도해 봐야 한다.</p>
<p><span class="math inline">\(\bullet\)</span> 자유도</p>
<p><a href="simple-reg.html#section-simple-sigma">2.3</a>절에서 살펴본 제곱합의 자유도를 구하는 두 가지 방법을 적용해서 <span class="math inline">\(RSS\)</span> 와 <span class="math inline">\((TSS-RSS)\)</span> 의 자유도를 구해보자.
먼저 <span class="math inline">\(RSS=\sum(y_{i}-\widehat{y}_{i})^{2}\)</span> 의 경우에는 <span class="math inline">\(n\)</span> 개의 <span class="math inline">\(y_{i}\)</span> 가 수집되지만 <span class="math inline">\(\widehat{y}_{i}\)</span> 를 얻기 위해 <span class="math inline">\((k+1)\)</span> 개 모수 <span class="math inline">\(\beta_{0}, \beta_{1}, \ldots, \beta_{k}\)</span> 에 대한 추정이 이루어져 <span class="math inline">\((k+1)\)</span> 개의 자유도를 잃게 되어서, 자유도는 <span class="math inline">\((n-k-1)\)</span> 이 된다.</p>
<p><span class="math inline">\((TSS-RSS)\)</span> 의 경우에는 제곱합을 수식으로 표현해야 자유도를 구할 수 있는데, 먼저 <span class="math inline">\(TSS=\sum(y_{i}-\overline{y})^{2}\)</span> 를 다음과 같이 분할해 보자.</p>
<p><span class="math display" id="eq:tss-partition">\[\begin{align}
\sum_{i=1}^{n}(y_{i}-\overline{y}_{i})^{2} &amp;= \sum_{i=1}^{n}(y_{i}-\widehat{y}_{i}+\widehat{y}_{i}-\overline{y})^{2} \\
&amp;= \sum_{i=1}^{n}(\widehat{y}_{i}-\overline{y})^{2} + \sum_{i=1}^{n}(y_{i}-\widehat{y}_{i})^{2} +2\sum_{i=1}^{n}(\widehat{y}_{i}-\overline{y})(y_{i}-\widehat{y}_{i}) \\
&amp;= \sum_{i=1}^{n}(\widehat{y}_{i}-\overline{y})^{2} + \sum_{i=1}^{n}(y_{i}-\widehat{y}_{i})^{2}
\tag{4.21}
\end{align}\]</span></p>
<p>마지막 수식은 <span class="math inline">\(\sum_{i=1}^{n}(\widehat{y}_{i}-\overline{y})(y_{i}-\widehat{y}_{i})=0\)</span> 이기 때문에 성립된다.</p>
<p>식 <a href="multiple-reg.html#eq:tss-partition">(4.21)</a>의 결과에서 <span class="math inline">\((TSS-RSS)\)</span> 는 다음과 같이 표현된다.</p>
<p><span class="math display">\[\begin{equation}
TSS-RSS = \sum_{i=1}^{n}(\widehat{y}_{i}-\overline{y})^{2}
\end{equation}\]</span></p>
<p>이제 수식으로 표현된 제곱합의 자유도를 구해보자.
<span class="math inline">\((TSS-RSS)\)</span> 에는 <span class="math inline">\(n\)</span> 개의 <span class="math inline">\(\widehat{y}_{i}\)</span> 이 있지만, <span class="math inline">\(y_{i}\)</span> 의 경우와는 다르게 <span class="math inline">\(\widehat{y}_{i}\)</span> 은 개별적으로 관측되는 것이 아니라 <span class="math inline">\((k+1)\)</span> 개의 회귀계수 추정값인 <span class="math inline">\(\hat{\beta}_{0}, \hat{\beta}_{1}, \ldots, \hat{\beta}_{k}\)</span> 에 의해서 결정되는 것이 때문에 <span class="math inline">\((k+1)\)</span> 개의 자유도로 시작한다.
또한 <span class="math inline">\(\sum(\widehat{y}_{i}-\overline{y})=0\)</span> 이 성립하기 때문에 하나의 제약조건이 존재하게 되어서, 자유도는 <span class="math inline">\((k+1)-1=k\)</span> 이 된다.</p>
</div>
<div id="개별-회귀계수-유의성-검정" class="section level3 hasAnchor" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> 개별 회귀계수 유의성 검정<a href="multiple-reg.html#개별-회귀계수-유의성-검정" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>회귀모형의 유의성 검정에서 적어도 하나의 유의적인 변수가 모형에 있다는 결론이 나면, 어떤 변수가 유의적 변수인지 확인해야 할 것이다.
개별회귀계수 유의성 검정은 식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>에 정의된 회귀모형을 구성하고 있는 각 설명변수의 유의성을 검정하는 절차이다.</p>
<p>가설은 다음과 같다.</p>
<p><span class="math display" id="eq:H0-2">\[\begin{equation}
H_{0}: \beta_{j} = 0, \quad H_{1}: \beta_{j} \ne 0, \quad j = 1, \ldots, k
\tag{4.22}
\end{equation}\]</span></p>
<p>검정통계량은 개별 회귀계수의 추정량 <span class="math inline">\(\hat{\beta}_{j}\)</span> 를 추정량의 표준오차로 나눈 것이다.</p>
<p><span class="math display">\[\begin{equation}
t = \frac{\hat{\beta}_{j}}{SE(\hat{\beta}_{j})}
\end{equation}\]</span></p>
<p>단, <span class="math inline">\(SE(\hat{\beta}_{j}) = \sqrt{c_{j+1,j+1}~MSE}\)</span> 이며, <span class="math inline">\(c_{j+1, j+1}\)</span> 은 <a href="multiple-reg.html#eq:multi-dist-lse-2">(4.16)</a>에 정의되어 있다.
귀무가설이 사실일 때 검정통계량의 분포는 <span class="math inline">\(t_{n-k-1}\)</span> 이다.</p>
<p>개별 회귀계수에 대한 검정은 양측검정이 되며, 따라서 회귀계수의 신뢰구간과 밀접한 관련이 있다. 개별 회귀계수에 대한 95% 신뢰구간은 회귀계수와 추정량과 추정량의 표준오차를 이용하여 대략적으로 다음과 같이 표시된다.</p>
<p><span class="math display">\[\begin{equation}
\hat{\beta}_{j} \pm 2 \cdot SE(\hat{\beta}_{j})
\end{equation}\]</span></p>
<p>만일 주어진 자료를 근거로 계산된 <span class="math inline">\(\beta_{j}\)</span> 의 95% 신뢰구간에 0이 포함되어 있다면, 같은 자료로 계산한 검정통계량의 값은 5% 유의수준으로 구성된 기각역에 들어갈 수 없게 되어서 귀무가설을 기각할 수 없게 된다.</p>
</div>
<div id="두-회귀모형의-비교" class="section level3 hasAnchor" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> 두 회귀모형의 비교<a href="multiple-reg.html#두-회귀모형의-비교" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>반응변수의 변동을 설명하는데 식 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a> 회귀모형의 설명변수를 모두 사용하는 것이 좋은지 아니면 일부분만을 사용하는 것이 더 좋은지 비교하는 절차이다.
비교하는 두 모형은 확장모형( <span class="math inline">\(\Omega\)</span> )인 모형 <a href="multiple-reg.html#eq:multi-reg">(4.1)</a>과 특정 <span class="math inline">\(q\)</span> 개의 회귀계수에 대한 다음의 가설이 사실인 축소모형( <span class="math inline">\(\omega\)</span> )이다.</p>
<p><span class="math display" id="eq:H0-3">\[\begin{equation}
H_{0}: \beta_{k-q+1}=\beta_{k-q+2}=\cdots=\beta_{k}=0
\tag{4.23}
\end{equation}\]</span></p>
<p>두 모형의 설명력 차이가 크지 않다면 ’모수절약의 원칙’에 의하여 축소모형을 선택하는 것이 더 좋을 것이다.
모형의 설명력 비교는 잔차제곱합을 이용할 수 있는데, 만일 확장모형의 잔차제곱합, <span class="math inline">\(RSS_{\Omega}\)</span> 와 축소모형의 잔차제곱합, <span class="math inline">\(RSS_{\omega}\)</span> 의 차이가 크지 않다면, 축소모형의 설명력이 확장모형 만큼 좋다는 의미가 된다.</p>
<p>검정통계량은 다음과 같이 구성된다.</p>
<p><span class="math display">\[\begin{equation}
F=\frac{(RSS_{\omega}-RSS_{\Omega})/q}{RSS_{\Omega}/(n-k-1)}
\end{equation}\]</span></p>
<p>귀무가설이 사실일 때 검정통게량의 분포는 <span class="math inline">\(F_{q,~n-k-1}\)</span> 이다.</p>
<p><span class="math inline">\(\bullet\)</span> 예제: <code>mtcars</code></p>
<p><a href="multiple-reg.html#section-multi-fitting">4.1.1</a>절에서 다루었던 <code>mtcars</code> 자료에 대한 분석을 다시 실행해 보자.
반응변수는 <code>mpg</code>이고, 설명변수로는 <code>gear</code>와 <code>carb</code>를 제외한 나머지 변수를 사용하며, <code>cyl</code>, <code>vs</code>, <code>am</code>은 요인으로 변경하자.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="multiple-reg.html#cb49-1" tabindex="-1"></a>mtcars_4 <span class="ot">&lt;-</span> mtcars <span class="sc">|&gt;</span> </span>
<span id="cb49-2"><a href="multiple-reg.html#cb49-2" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">!</span><span class="fu">c</span>(gear, carb)) <span class="sc">|&gt;</span> </span>
<span id="cb49-3"><a href="multiple-reg.html#cb49-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">c</span>(cyl, vs, am), as.factor))</span></code></pre></div>
<p><code>mtcars_4</code>를 사용해서 회귀모형 <code>fit_m3</code>를 적합해 보자.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="multiple-reg.html#cb50-1" tabindex="-1"></a>fit_m3 <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> ., mtcars_4)</span></code></pre></div>
<p>이제 <code>lm()</code>으로 생성된 객체 <code>fit_m3</code>를 대상으로 회귀모형 추론을 위한 몇 가지 함수를 적용해 보자.
먼저 가장 빈번하게 사용되는 함수인 <code>summary()</code>의 결과를 확인해 보자.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="multiple-reg.html#cb51-1" tabindex="-1"></a><span class="fu">summary</span>(fit_m3)</span>
<span id="cb51-2"><a href="multiple-reg.html#cb51-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb51-3"><a href="multiple-reg.html#cb51-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb51-4"><a href="multiple-reg.html#cb51-4" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ ., data = mtcars_4)</span></span>
<span id="cb51-5"><a href="multiple-reg.html#cb51-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb51-6"><a href="multiple-reg.html#cb51-6" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb51-7"><a href="multiple-reg.html#cb51-7" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb51-8"><a href="multiple-reg.html#cb51-8" tabindex="-1"></a><span class="do">## -3.9978 -1.3551 -0.3108  1.1992  4.1102 </span></span>
<span id="cb51-9"><a href="multiple-reg.html#cb51-9" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb51-10"><a href="multiple-reg.html#cb51-10" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb51-11"><a href="multiple-reg.html#cb51-11" tabindex="-1"></a><span class="do">##              Estimate Std. Error t value Pr(&gt;|t|)  </span></span>
<span id="cb51-12"><a href="multiple-reg.html#cb51-12" tabindex="-1"></a><span class="do">## (Intercept) 19.865583  14.801183   1.342   0.1932  </span></span>
<span id="cb51-13"><a href="multiple-reg.html#cb51-13" tabindex="-1"></a><span class="do">## cyl6        -1.458247   1.983190  -0.735   0.4699  </span></span>
<span id="cb51-14"><a href="multiple-reg.html#cb51-14" tabindex="-1"></a><span class="do">## cyl8         0.484450   3.910064   0.124   0.9025  </span></span>
<span id="cb51-15"><a href="multiple-reg.html#cb51-15" tabindex="-1"></a><span class="do">## disp         0.006688   0.013512   0.495   0.6255  </span></span>
<span id="cb51-16"><a href="multiple-reg.html#cb51-16" tabindex="-1"></a><span class="do">## hp          -0.029141   0.017182  -1.696   0.1040  </span></span>
<span id="cb51-17"><a href="multiple-reg.html#cb51-17" tabindex="-1"></a><span class="do">## drat         0.588059   1.503111   0.391   0.6994  </span></span>
<span id="cb51-18"><a href="multiple-reg.html#cb51-18" tabindex="-1"></a><span class="do">## wt          -3.155246   1.420235  -2.222   0.0369 *</span></span>
<span id="cb51-19"><a href="multiple-reg.html#cb51-19" tabindex="-1"></a><span class="do">## qsec         0.523235   0.690130   0.758   0.4564  </span></span>
<span id="cb51-20"><a href="multiple-reg.html#cb51-20" tabindex="-1"></a><span class="do">## vs1          1.237800   2.106056   0.588   0.5627  </span></span>
<span id="cb51-21"><a href="multiple-reg.html#cb51-21" tabindex="-1"></a><span class="do">## am1          3.000910   1.853400   1.619   0.1197  </span></span>
<span id="cb51-22"><a href="multiple-reg.html#cb51-22" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb51-23"><a href="multiple-reg.html#cb51-23" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb51-24"><a href="multiple-reg.html#cb51-24" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb51-25"><a href="multiple-reg.html#cb51-25" tabindex="-1"></a><span class="do">## Residual standard error: 2.514 on 22 degrees of freedom</span></span>
<span id="cb51-26"><a href="multiple-reg.html#cb51-26" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.8765, Adjusted R-squared:  0.826 </span></span>
<span id="cb51-27"><a href="multiple-reg.html#cb51-27" tabindex="-1"></a><span class="do">## F-statistic: 17.35 on 9 and 22 DF,  p-value: 4.814e-08</span></span></code></pre></div>
<p>함수 <code>lm()</code>으로 생성된 객체에 함수 <code>summary()</code>를 적용시켜 얻은 결과물은 SAS나 SPSS에서 볼 수 있는 결과물과는 형식에서 차이가 있으나 많은 정보를 매우 효과적으로 보여주는 방식이라고 할 수 있다. 결과물을 하나씩 살펴보자.</p>
<p>먼저 <code>Residuals:</code>에는 잔차의 분포를 엿볼 수 있는 요약통계가 계산되어 있다.
가정이 만족된다면 잔차는 평균이 0인 정규분포를 보이게 되는데, 잔차의 요약 통계 결과 값으로 대략적인 판단을 할 수 있다.</p>
<p><code>Coefficients:</code>에는 회귀계수의 추정값과 표준오차가 계산되어 있다.
또한 개별 회귀계수의 유의성 검정인 <span class="math inline">\(H_{0}:\beta_{j} = 0, \quad H_{1}: \beta_{j} \ne 0\)</span> 에 대한 검정통계량의 값과 p-값이 계산되어 있다</p>
<p><code>Residual standard error:</code>는 <span class="math inline">\(\sqrt{MSE}\)</span> 이며, <code>Multiple R-squared:</code>는 결정계수 <span class="math inline">\(R^{2}\)</span> 이고, <code>Adjusted R-squared:</code>는 수정결정계수의 값으로서, 모두 회귀모형의 평가 측도로 사용된다.
회귀모형의 평가측도에 대해서는 <a href="multiple-reg.html#section-selection">4.3</a>절에서 살펴보겠다.</p>
<p><code>F-statistic:</code>은 모든 회귀계수가 0이라는 가설, 즉 <span class="math inline">\(H_{0}:\beta_{1}=\beta_{2}=\cdots=\beta_{k}=0\)</span> 에 대한 검정통계량의 값과 자유도, 그리고 p-값이 계산되어 있다.</p>
<p>함수 <code>summary()</code>로 얻어지는 결과물로 회귀모형에 대한 중요한 추론이 가능함을 알 수 있다.
한 가지 SAS나 SPSS에 익숙한 사용자들에게 아쉬울 수 있는 점은 아마도 회귀모형의 분산분석표가 출력되지 않는다는 것일 텐데, 이것은 함수 <code>anova()</code>를 사용함으로써 해결할 수 있다.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="multiple-reg.html#cb52-1" tabindex="-1"></a><span class="fu">anova</span>(fit_m3)</span>
<span id="cb52-2"><a href="multiple-reg.html#cb52-2" tabindex="-1"></a><span class="do">## Analysis of Variance Table</span></span>
<span id="cb52-3"><a href="multiple-reg.html#cb52-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb52-4"><a href="multiple-reg.html#cb52-4" tabindex="-1"></a><span class="do">## Response: mpg</span></span>
<span id="cb52-5"><a href="multiple-reg.html#cb52-5" tabindex="-1"></a><span class="do">##           Df Sum Sq Mean Sq F value    Pr(&gt;F)    </span></span>
<span id="cb52-6"><a href="multiple-reg.html#cb52-6" tabindex="-1"></a><span class="do">## cyl        2 824.78  412.39 65.2599 5.624e-10 ***</span></span>
<span id="cb52-7"><a href="multiple-reg.html#cb52-7" tabindex="-1"></a><span class="do">## disp       1  57.64   57.64  9.1218  0.006292 ** </span></span>
<span id="cb52-8"><a href="multiple-reg.html#cb52-8" tabindex="-1"></a><span class="do">## hp         1  18.50   18.50  2.9279  0.101125    </span></span>
<span id="cb52-9"><a href="multiple-reg.html#cb52-9" tabindex="-1"></a><span class="do">## drat       1  11.91   11.91  1.8854  0.183553    </span></span>
<span id="cb52-10"><a href="multiple-reg.html#cb52-10" tabindex="-1"></a><span class="do">## wt         1  55.79   55.79  8.8281  0.007049 ** </span></span>
<span id="cb52-11"><a href="multiple-reg.html#cb52-11" tabindex="-1"></a><span class="do">## qsec       1   1.52    1.52  0.2413  0.628165    </span></span>
<span id="cb52-12"><a href="multiple-reg.html#cb52-12" tabindex="-1"></a><span class="do">## vs         1   0.30    0.30  0.0478  0.828944    </span></span>
<span id="cb52-13"><a href="multiple-reg.html#cb52-13" tabindex="-1"></a><span class="do">## am         1  16.57   16.57  2.6216  0.119666    </span></span>
<span id="cb52-14"><a href="multiple-reg.html#cb52-14" tabindex="-1"></a><span class="do">## Residuals 22 139.02    6.32                      </span></span>
<span id="cb52-15"><a href="multiple-reg.html#cb52-15" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb52-16"><a href="multiple-reg.html#cb52-16" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span></code></pre></div>
<p>함수 <code>anova()</code>는 두 회귀모형을 비교할 때에도 사용되는 함수이다.
비교되는 두 모형은 확장모형과 확장모형의 부분집합인 축소모형이어야 한다.
확장모형의 부분집합이라는 것은 확장모형의 일부 회귀계수가 0이 되는 모형을 의미하는 것으로써, 확장모형에 없는 설명변수가 축소모형에 포함되면 정상적인 비교가 이루어질 수 없다.</p>
<p><code>mtcars_4</code> 자료에서 모든 설명변수가 포함된 확장모형 <code>fit_m3</code>와 변수 <code>cyl</code>, <code>vs</code>, <code>drat</code>를 제외한 축소모형 <code>fit_m4</code>를 비교해 보자.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="multiple-reg.html#cb53-1" tabindex="-1"></a>fit_m4 <span class="ot">&lt;-</span> <span class="fu">update</span>(fit_m3, . <span class="sc">~</span> . <span class="sc">-</span> cyl <span class="sc">-</span> vs <span class="sc">-</span> drat)</span></code></pre></div>
<p>축소모형 <code>fit_m4</code>는 확장모형 <code>fit_m3</code>의 적합 내용을 변경한 것인데, 이런 경우에 유용하게 사용되는 함수가 <code>update()</code>이며, 사용법은 다음과 같다.</p>
<p><code>update(object, formula)</code></p>
<p><code>object</code>는 <code>lm()</code>로 생성된 객체이고, <code>formula</code>는 <code>object</code>의 적합 내용 중 변경되는 모형의 공식을 지정하는 것이다.
모형 <code>fit_m4</code>에 적용된 모형공식은 <code>. ~ . - cyl - vs - drat</code>인데, 이것은 <code>fit_m3</code>에 적용된 모형공식 중 설명변수에서 <code>cyl</code>, <code>vs</code>, <code>drat</code>를 제거하는 것을 의미한다.</p>
<p>두 회귀모형 <code>fit_m3</code>와 <code>fit_m4</code>의 비교를 함수 <code>anova()</code>로 진행하자.
함수 <code>anova()</code>에 의한 비교 방법은 <code>anova(축소모형, 확장모형)</code>으로 지정되어야 한다.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="multiple-reg.html#cb54-1" tabindex="-1"></a><span class="fu">anova</span>(fit_m4, fit_m3)</span>
<span id="cb54-2"><a href="multiple-reg.html#cb54-2" tabindex="-1"></a><span class="do">## Analysis of Variance Table</span></span>
<span id="cb54-3"><a href="multiple-reg.html#cb54-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb54-4"><a href="multiple-reg.html#cb54-4" tabindex="-1"></a><span class="do">## Model 1: mpg ~ disp + hp + wt + qsec + am</span></span>
<span id="cb54-5"><a href="multiple-reg.html#cb54-5" tabindex="-1"></a><span class="do">## Model 2: mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am</span></span>
<span id="cb54-6"><a href="multiple-reg.html#cb54-6" tabindex="-1"></a><span class="do">##   Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)</span></span>
<span id="cb54-7"><a href="multiple-reg.html#cb54-7" tabindex="-1"></a><span class="do">## 1     26 153.44                           </span></span>
<span id="cb54-8"><a href="multiple-reg.html#cb54-8" tabindex="-1"></a><span class="do">## 2     22 139.02  4    14.415 0.5703 0.6869</span></span></code></pre></div>
<p>함수 <code>anova()</code>로 검정이 실시된 귀무가설은 변수 <code>cyl</code>, <code>vs</code>, <code>drat</code>의 회귀계수가 0이라는 것인데, p-값이 0.687으로 계산되어 귀무가설을 기각할 수 없게 되었다.
두 모형의 설명력에는 차이가 없다는 것이므로, 모수 절약의 원칙에 따라 축소모형을 선택하는 것이 더 좋다고 하겠다.</p>
<p>다중회귀모형에서 회귀계수의 유의성은 모형에 포함된 설명변수의 조합에 따라 달라질 수 있음에 유의해야 한다.
모형 <code>fit_m3</code>가 아닌 <code>fit_m4</code>를 선택했다는 것이 제외된 변수인 <code>cyl</code>, <code>vs</code>, <code>drat</code>가 항상 비유의적인 변수라는 것을 의미하는 것은 아니다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="multiple-reg.html#cb55-1" tabindex="-1"></a><span class="fu">lm</span>(mpg <span class="sc">~</span> drat, mtcars_4) <span class="sc">|&gt;</span> </span>
<span id="cb55-2"><a href="multiple-reg.html#cb55-2" tabindex="-1"></a>  <span class="fu">summary</span>()</span>
<span id="cb55-3"><a href="multiple-reg.html#cb55-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb55-4"><a href="multiple-reg.html#cb55-4" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb55-5"><a href="multiple-reg.html#cb55-5" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ drat, data = mtcars_4)</span></span>
<span id="cb55-6"><a href="multiple-reg.html#cb55-6" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb55-7"><a href="multiple-reg.html#cb55-7" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb55-8"><a href="multiple-reg.html#cb55-8" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb55-9"><a href="multiple-reg.html#cb55-9" tabindex="-1"></a><span class="do">## -9.0775 -2.6803 -0.2095  2.2976  9.0225 </span></span>
<span id="cb55-10"><a href="multiple-reg.html#cb55-10" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb55-11"><a href="multiple-reg.html#cb55-11" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb55-12"><a href="multiple-reg.html#cb55-12" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb55-13"><a href="multiple-reg.html#cb55-13" tabindex="-1"></a><span class="do">## (Intercept)   -7.525      5.477  -1.374     0.18    </span></span>
<span id="cb55-14"><a href="multiple-reg.html#cb55-14" tabindex="-1"></a><span class="do">## drat           7.678      1.507   5.096 1.78e-05 ***</span></span>
<span id="cb55-15"><a href="multiple-reg.html#cb55-15" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb55-16"><a href="multiple-reg.html#cb55-16" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb55-17"><a href="multiple-reg.html#cb55-17" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb55-18"><a href="multiple-reg.html#cb55-18" tabindex="-1"></a><span class="do">## Residual standard error: 4.485 on 30 degrees of freedom</span></span>
<span id="cb55-19"><a href="multiple-reg.html#cb55-19" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.464,  Adjusted R-squared:  0.4461 </span></span>
<span id="cb55-20"><a href="multiple-reg.html#cb55-20" tabindex="-1"></a><span class="do">## F-statistic: 25.97 on 1 and 30 DF,  p-value: 1.776e-05</span></span></code></pre></div>
<p>변수 <code>drat</code>만 사용한 회귀모형에서 <code>drat</code>는 유의적인 변수이고,</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="multiple-reg.html#cb56-1" tabindex="-1"></a><span class="fu">lm</span>(mpg <span class="sc">~</span> drat <span class="sc">+</span> cyl, mtcars_4) <span class="sc">|&gt;</span> </span>
<span id="cb56-2"><a href="multiple-reg.html#cb56-2" tabindex="-1"></a>  <span class="fu">summary</span>()</span>
<span id="cb56-3"><a href="multiple-reg.html#cb56-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb56-4"><a href="multiple-reg.html#cb56-4" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb56-5"><a href="multiple-reg.html#cb56-5" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ drat + cyl, data = mtcars_4)</span></span>
<span id="cb56-6"><a href="multiple-reg.html#cb56-6" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb56-7"><a href="multiple-reg.html#cb56-7" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb56-8"><a href="multiple-reg.html#cb56-8" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb56-9"><a href="multiple-reg.html#cb56-9" tabindex="-1"></a><span class="do">## -5.3337 -1.8212 -0.1335  1.7382  6.9691 </span></span>
<span id="cb56-10"><a href="multiple-reg.html#cb56-10" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb56-11"><a href="multiple-reg.html#cb56-11" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb56-12"><a href="multiple-reg.html#cb56-12" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb56-13"><a href="multiple-reg.html#cb56-13" tabindex="-1"></a><span class="do">## (Intercept)   19.366      6.219   3.114  0.00423 ** </span></span>
<span id="cb56-14"><a href="multiple-reg.html#cb56-14" tabindex="-1"></a><span class="do">## drat           1.793      1.509   1.188  0.24488    </span></span>
<span id="cb56-15"><a href="multiple-reg.html#cb56-15" tabindex="-1"></a><span class="do">## cyl6          -6.051      1.712  -3.535  0.00144 ** </span></span>
<span id="cb56-16"><a href="multiple-reg.html#cb56-16" tabindex="-1"></a><span class="do">## cyl8         -10.055      1.810  -5.555 6.09e-06 ***</span></span>
<span id="cb56-17"><a href="multiple-reg.html#cb56-17" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb56-18"><a href="multiple-reg.html#cb56-18" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb56-19"><a href="multiple-reg.html#cb56-19" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb56-20"><a href="multiple-reg.html#cb56-20" tabindex="-1"></a><span class="do">## Residual standard error: 3.201 on 28 degrees of freedom</span></span>
<span id="cb56-21"><a href="multiple-reg.html#cb56-21" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.7453, Adjusted R-squared:  0.718 </span></span>
<span id="cb56-22"><a href="multiple-reg.html#cb56-22" tabindex="-1"></a><span class="do">## F-statistic: 27.31 on 3 and 28 DF,  p-value: 1.83e-08</span></span></code></pre></div>
<p>변수 <code>drat</code>와 <code>cyl</code>을 함께 사용한 모형에서는 <code>drat</code>가 비유의적인 변수가 되었음을 알 수 있다.</p>
<p>회귀계수의 신뢰구간은 함수 <code>confint()</code>로 계산할 수 있다. 95% 신뢰구간이 디폴트로 계산되며, 만일 신뢰수준을 변경하고자 한다면 옵션 <code>level</code>에 원하는 신뢰수준을 입력하면 된다. 객체 <code>fit1</code>에 포함되어 있는 회귀계수의 95% 신뢰구간은 다음과 같이 계산된다.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="multiple-reg.html#cb57-1" tabindex="-1"></a><span class="fu">confint</span>(fit_m4)</span>
<span id="cb57-2"><a href="multiple-reg.html#cb57-2" tabindex="-1"></a><span class="do">##                   2.5 %       97.5 %</span></span>
<span id="cb57-3"><a href="multiple-reg.html#cb57-3" tabindex="-1"></a><span class="do">## (Intercept) -5.66058661 34.384394537</span></span>
<span id="cb57-4"><a href="multiple-reg.html#cb57-4" tabindex="-1"></a><span class="do">## disp        -0.01055781  0.033033109</span></span>
<span id="cb57-5"><a href="multiple-reg.html#cb57-5" tabindex="-1"></a><span class="do">## hp          -0.05098537  0.008644273</span></span>
<span id="cb57-6"><a href="multiple-reg.html#cb57-6" tabindex="-1"></a><span class="do">## wt          -6.53883919 -1.629824922</span></span>
<span id="cb57-7"><a href="multiple-reg.html#cb57-7" tabindex="-1"></a><span class="do">## qsec         0.02963058  1.984163085</span></span>
<span id="cb57-8"><a href="multiple-reg.html#cb57-8" tabindex="-1"></a><span class="do">## am1          0.41638869  6.524518102</span></span></code></pre></div>
<p>회귀계수의 95% 신뢰구간에 0이 포함됐다는 것은 5% 유의수준에서 가설 <span class="math inline">\(H_{0}:\beta_{j}=0, \quad H_{1}:\beta_{j} \ne 0\)</span> 의 귀무가설을 기각할 수 없음을 의미한다. 따라서 95% 신뢰구간에 0이 포함된 변수 <code>disp</code>, <code>hp</code>는 5% 유의수준에서 비유적인 변수인 것이다.</p>
<p><span class="math inline">\(\bullet\)</span> 가변수 회귀모형 : 가변수와 연속형 변수의 상호작용 항 포함 여부</p>
<p>설명변수 중 범주형 변수가 있다면, 그 변수에 대한 가변수를 사용해야 하는데, 이 경우에 모형에 포함된 숫자형 설명변수와 반응변수의 관계가 범주형 변수의 모든 범주에서 동일하다고 가정하는 식 <a href="multiple-reg.html#eq:dummy-1">(4.13)</a>의 모형을 사용할 수 있다.
<code>mtcars_4</code> 자료에서 반응변수 <code>mpg</code>와 설명변수 <code>qsec</code>, <code>am</code>의 회귀모형을 다음과 같이 적합한다면, <code>am</code>의 두 범주에서 <code>mpg</code>와 <code>qsec</code>의 기울기가 동일하다고 가정한 것이 된다.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="multiple-reg.html#cb58-1" tabindex="-1"></a>fit_m5 <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> qsec <span class="sc">+</span> am, mtcars_4)</span></code></pre></div>
<p>모형 <code>fit_m5</code>의 적합 결과에 대한 그래프는 그림 <a href="multiple-reg.html#fig:ex4-4-1">4.5</a>에서 볼 수 있다.</p>
<p>그러나 만일 숫자형 설명변수와 반응변수의 관계가 각 범주에서 다르다고 판단이 된다면, 식 <a href="multiple-reg.html#eq:dummy-2">(4.14)</a>의 모형을 선택해서, 가변수와 연속형 변수의 상호작용 항을 포함시켜야 한다.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="multiple-reg.html#cb59-1" tabindex="-1"></a>fit_m6 <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> qsec <span class="sc">*</span> am, mtcars_4)</span></code></pre></div>
<p>모형 <code>fit_m6</code>의 모형 공식에 사용된 <code>*</code> 기호는 두 변수의 주 효과와 상호작용 효과를 모두 포함시키는 작용을 한다.
모형 <code>fit_m6</code>의 적합 결과에 대한 그래프는 그림 <a href="multiple-reg.html#fig:ex4-4-2">4.6</a>에서 볼 수 있다.</p>
<p>두 모형 중 어떤 모형을 선택할 것인지는 모형 <code>fit_m6</code>에 포함된 상호작용 항의 유의성 여부로 결정할 수 있으나, 모형 수립 목적에 부합한 평가 기준을 사용하는 것이 더 좋은 방법이라고 하겠다.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="multiple-reg.html#cb60-1" tabindex="-1"></a><span class="fu">summary</span>(fit_m6)</span>
<span id="cb60-2"><a href="multiple-reg.html#cb60-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb60-3"><a href="multiple-reg.html#cb60-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb60-4"><a href="multiple-reg.html#cb60-4" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ qsec * am, data = mtcars_4)</span></span>
<span id="cb60-5"><a href="multiple-reg.html#cb60-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb60-6"><a href="multiple-reg.html#cb60-6" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb60-7"><a href="multiple-reg.html#cb60-7" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb60-8"><a href="multiple-reg.html#cb60-8" tabindex="-1"></a><span class="do">## -6.4551 -1.4331  0.1918  2.2493  7.2773 </span></span>
<span id="cb60-9"><a href="multiple-reg.html#cb60-9" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb60-10"><a href="multiple-reg.html#cb60-10" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb60-11"><a href="multiple-reg.html#cb60-11" tabindex="-1"></a><span class="do">##             Estimate Std. Error t value Pr(&gt;|t|)   </span></span>
<span id="cb60-12"><a href="multiple-reg.html#cb60-12" tabindex="-1"></a><span class="do">## (Intercept)  -9.0099     8.2179  -1.096  0.28226   </span></span>
<span id="cb60-13"><a href="multiple-reg.html#cb60-13" tabindex="-1"></a><span class="do">## qsec          1.4385     0.4500   3.197  0.00343 **</span></span>
<span id="cb60-14"><a href="multiple-reg.html#cb60-14" tabindex="-1"></a><span class="do">## am1         -14.5107    12.4812  -1.163  0.25481   </span></span>
<span id="cb60-15"><a href="multiple-reg.html#cb60-15" tabindex="-1"></a><span class="do">## qsec:am1      1.3214     0.7017   1.883  0.07012 . </span></span>
<span id="cb60-16"><a href="multiple-reg.html#cb60-16" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb60-17"><a href="multiple-reg.html#cb60-17" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb60-18"><a href="multiple-reg.html#cb60-18" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb60-19"><a href="multiple-reg.html#cb60-19" tabindex="-1"></a><span class="do">## Residual standard error: 3.343 on 28 degrees of freedom</span></span>
<span id="cb60-20"><a href="multiple-reg.html#cb60-20" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.722,  Adjusted R-squared:  0.6923 </span></span>
<span id="cb60-21"><a href="multiple-reg.html#cb60-21" tabindex="-1"></a><span class="do">## F-statistic: 24.24 on 3 and 28 DF,  p-value: 6.129e-08</span></span></code></pre></div>
<p><span class="math inline">\(\bullet\)</span> 예제 : <code>modeldata::crickets</code></p>
<p>패키지 <code>modeldata</code>의 데이터 프레임 <code>crickets</code>에는 기온과 귀뚜라미 울음소리 횟수의 관계를 탐색하기 위해 관측한 자료가 입력되어 있다.
변수 <code>temp</code>는 기온, <code>rate</code>는 귀뚜라미의 분당 울음소리 횟수이며, <code>species</code>는 귀뚜라미 종류이다.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="multiple-reg.html#cb61-1" tabindex="-1"></a><span class="fu">data</span>(crickets, <span class="at">package =</span> <span class="st">&quot;modeldata&quot;</span>)</span>
<span id="cb61-2"><a href="multiple-reg.html#cb61-2" tabindex="-1"></a><span class="fu">str</span>(crickets)</span>
<span id="cb61-3"><a href="multiple-reg.html#cb61-3" tabindex="-1"></a><span class="do">## tibble [31 × 3] (S3: tbl_df/tbl/data.frame)</span></span>
<span id="cb61-4"><a href="multiple-reg.html#cb61-4" tabindex="-1"></a><span class="do">##  $ species: Factor w/ 2 levels &quot;O. exclamationis&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span></span>
<span id="cb61-5"><a href="multiple-reg.html#cb61-5" tabindex="-1"></a><span class="do">##  $ temp   : num [1:31] 20.8 20.8 24 24 24 24 26.2 26.2 26.2 26.2 ...</span></span>
<span id="cb61-6"><a href="multiple-reg.html#cb61-6" tabindex="-1"></a><span class="do">##  $ rate   : num [1:31] 67.9 65.1 77.3 78.7 79.4 80.4 85.8 86.6 87.5 89.1 ...</span></span></code></pre></div>
<p>세 변수의 관계 탐색을 위한 그래프를 작성해 보자.
변수 <code>temp</code>와 <code>rate</code>의 단순 산점도와 <code>species</code>의 효과를 살펴볼 수 있는 산점도를 모두 작성해 보자.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="multiple-reg.html#cb62-1" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb62-2"><a href="multiple-reg.html#cb62-2" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(crickets, <span class="fu">aes</span>(<span class="at">x =</span> temp, <span class="at">y =</span> rate)) <span class="sc">+</span></span>
<span id="cb62-3"><a href="multiple-reg.html#cb62-3" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span>
<span id="cb62-4"><a href="multiple-reg.html#cb62-4" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(crickets, <span class="fu">aes</span>(<span class="at">x =</span> temp, <span class="at">y =</span> rate, <span class="at">color =</span> species)) <span class="sc">+</span></span>
<span id="cb62-5"><a href="multiple-reg.html#cb62-5" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span>
<span id="cb62-6"><a href="multiple-reg.html#cb62-6" tabindex="-1"></a>p1 <span class="sc">+</span> p2</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:c-1"></span>
<img src="_main_files/figure-html/c-1-1.png" alt="`crickets` 자료의 세 변수 관계 탐색" width="768" />
<p class="caption">
그림 4.8: <code>crickets</code> 자료의 세 변수 관계 탐색
</p>
</div>
<p>변수 <code>temp</code>와 <code>rate</code> 사이에는 명확한 양의 관계가 있는데, <code>species</code>의 두 범주 사이에는 효과 차이가 있는 것으로 보인다.
가변수를 사용한 선형회귀모형을 사용하는 것이 적절한 것으로 보이는데, 두 범주에서 변수 <code>temp</code>와 <code>rate</code>의 관계가 동일한지 여부를 확인하기 위해서 그림 <a href="multiple-reg.html#fig:c-1">4.8</a>의 오른쪽 그래프에 회귀직선을 추가해 보자.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="multiple-reg.html#cb63-1" tabindex="-1"></a><span class="fu">ggplot</span>(crickets, <span class="fu">aes</span>(<span class="at">x =</span> temp, <span class="at">y =</span> rate, <span class="at">color =</span> species)) <span class="sc">+</span></span>
<span id="cb63-2"><a href="multiple-reg.html#cb63-2" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb63-3"><a href="multiple-reg.html#cb63-3" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="at">se =</span> <span class="cn">FALSE</span>) <span class="sc">+</span></span>
<span id="cb63-4"><a href="multiple-reg.html#cb63-4" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;Temperature (C)&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Chirp Rate (per minute)&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:c-2"></span>
<img src="_main_files/figure-html/c-2-1.png" alt="`crickets` 자료의 세 변수 관계 탐색" width="576" />
<p class="caption">
그림 4.9: <code>crickets</code> 자료의 세 변수 관계 탐색
</p>
</div>
<p>그림 <a href="multiple-reg.html#fig:c-2">4.9</a>에서 두 직선의 기울기는 큰 차이가 없는 것으로 보인다.
따라서 <code>temp</code>와 <code>species</code>의 상호작용 효과는 필요 없는 것으로 보이는데, 이것을 검정을 통해 확인해 보자.</p>
<p>식 <a href="multiple-reg.html#eq:dummy-1">(4.13)</a>의 모형으로 <code>fit.main</code>을 적합하고, 식 <a href="multiple-reg.html#eq:dummy-2">(4.14)</a>의 모형으로 <code>fit.inter</code>을 적합해 보자.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="multiple-reg.html#cb64-1" tabindex="-1"></a>fit.main <span class="ot">&lt;-</span> <span class="fu">lm</span>(rate <span class="sc">~</span> temp <span class="sc">+</span> species, <span class="at">data =</span> crickets)</span>
<span id="cb64-2"><a href="multiple-reg.html#cb64-2" tabindex="-1"></a>fit.inter <span class="ot">&lt;-</span> <span class="fu">lm</span>(rate <span class="sc">~</span> temp <span class="sc">*</span> species, <span class="at">data =</span> crickets)</span></code></pre></div>
<p>모형 <code>fit.main</code>은 <code>fit.inter</code>에서 상호작용 효과만 제외된 모형으므로 <code>fit.inter</code>의 축소모형이 된다.
따라서 상호작용 효과의 유의성 여부는 함수 <code>anova()</code>를 사용해서 두 모형을 비교해서 획인할 수 있다.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="multiple-reg.html#cb65-1" tabindex="-1"></a><span class="fu">anova</span>(fit.main, fit.inter)</span>
<span id="cb65-2"><a href="multiple-reg.html#cb65-2" tabindex="-1"></a><span class="do">## Analysis of Variance Table</span></span>
<span id="cb65-3"><a href="multiple-reg.html#cb65-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb65-4"><a href="multiple-reg.html#cb65-4" tabindex="-1"></a><span class="do">## Model 1: rate ~ temp + species</span></span>
<span id="cb65-5"><a href="multiple-reg.html#cb65-5" tabindex="-1"></a><span class="do">## Model 2: rate ~ temp * species</span></span>
<span id="cb65-6"><a href="multiple-reg.html#cb65-6" tabindex="-1"></a><span class="do">##   Res.Df    RSS Df Sum of Sq     F Pr(&gt;F)</span></span>
<span id="cb65-7"><a href="multiple-reg.html#cb65-7" tabindex="-1"></a><span class="do">## 1     28 89.350                          </span></span>
<span id="cb65-8"><a href="multiple-reg.html#cb65-8" tabindex="-1"></a><span class="do">## 2     27 85.074  1    4.2758 1.357 0.2542</span></span></code></pre></div>
<p>검정 결과 p-값이 0.2542로 계산되어서, 두 모형의 설명력에는 차이가 없는 것으로 볼 수 있다.
따라서 축소모형인 <code>fit.main</code>을 선택하게 되고, 상호작용 효과는 비유의적이라고 결론내릴 수 있다.</p>
<p>물론 모형 <code>fit.inter</code>의 개별회귀계수 검정으로도 동일한 가설을 검정할 수 있다.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="multiple-reg.html#cb66-1" tabindex="-1"></a><span class="fu">summary</span>(fit.inter)<span class="sc">$</span>coef</span>
<span id="cb66-2"><a href="multiple-reg.html#cb66-2" tabindex="-1"></a><span class="do">##                          Estimate Std. Error    t value     Pr(&gt;|t|)</span></span>
<span id="cb66-3"><a href="multiple-reg.html#cb66-3" tabindex="-1"></a><span class="do">## (Intercept)           -11.0408481  4.1514800 -2.6594969 1.300079e-02</span></span>
<span id="cb66-4"><a href="multiple-reg.html#cb66-4" tabindex="-1"></a><span class="do">## temp                    3.7514472  0.1601220 23.4286850 1.780831e-19</span></span>
<span id="cb66-5"><a href="multiple-reg.html#cb66-5" tabindex="-1"></a><span class="do">## speciesO. niveus       -4.3484072  4.9616805 -0.8763981 3.885447e-01</span></span>
<span id="cb66-6"><a href="multiple-reg.html#cb66-6" tabindex="-1"></a><span class="do">## temp:speciesO. niveus  -0.2339856  0.2008622 -1.1649059 2.542464e-01</span></span></code></pre></div>
<p>모형 <code>fit.main</code>의 적합 결과를 확인해 보자.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="multiple-reg.html#cb67-1" tabindex="-1"></a><span class="fu">summary</span>(fit.main)</span>
<span id="cb67-2"><a href="multiple-reg.html#cb67-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb67-3"><a href="multiple-reg.html#cb67-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb67-4"><a href="multiple-reg.html#cb67-4" tabindex="-1"></a><span class="do">## lm(formula = rate ~ temp + species, data = crickets)</span></span>
<span id="cb67-5"><a href="multiple-reg.html#cb67-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb67-6"><a href="multiple-reg.html#cb67-6" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb67-7"><a href="multiple-reg.html#cb67-7" tabindex="-1"></a><span class="do">##     Min      1Q  Median      3Q     Max </span></span>
<span id="cb67-8"><a href="multiple-reg.html#cb67-8" tabindex="-1"></a><span class="do">## -3.0128 -1.1296 -0.3912  0.9650  3.7800 </span></span>
<span id="cb67-9"><a href="multiple-reg.html#cb67-9" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb67-10"><a href="multiple-reg.html#cb67-10" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb67-11"><a href="multiple-reg.html#cb67-11" tabindex="-1"></a><span class="do">##                   Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb67-12"><a href="multiple-reg.html#cb67-12" tabindex="-1"></a><span class="do">## (Intercept)       -7.21091    2.55094  -2.827  0.00858 ** </span></span>
<span id="cb67-13"><a href="multiple-reg.html#cb67-13" tabindex="-1"></a><span class="do">## temp               3.60275    0.09729  37.032  &lt; 2e-16 ***</span></span>
<span id="cb67-14"><a href="multiple-reg.html#cb67-14" tabindex="-1"></a><span class="do">## speciesO. niveus -10.06529    0.73526 -13.689 6.27e-14 ***</span></span>
<span id="cb67-15"><a href="multiple-reg.html#cb67-15" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb67-16"><a href="multiple-reg.html#cb67-16" tabindex="-1"></a><span class="do">## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span>
<span id="cb67-17"><a href="multiple-reg.html#cb67-17" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb67-18"><a href="multiple-reg.html#cb67-18" tabindex="-1"></a><span class="do">## Residual standard error: 1.786 on 28 degrees of freedom</span></span>
<span id="cb67-19"><a href="multiple-reg.html#cb67-19" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.9896, Adjusted R-squared:  0.9888 </span></span>
<span id="cb67-20"><a href="multiple-reg.html#cb67-20" tabindex="-1"></a><span class="do">## F-statistic:  1331 on 2 and 28 DF,  p-value: &lt; 2.2e-16</span></span></code></pre></div>
</div>
</div>
<div id="section-selection" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> 변수선택<a href="multiple-reg.html#section-selection" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>반응변수 <span class="math inline">\(Y\)</span> 에 대한 다음의 회귀모형에는 모든 가능한 설명변수가 다 포함되어 있다고 가정하고, 그런 의미에서 완전모형 또는 full model이라고 하자.</p>
<p><span class="math display" id="eq:full-model">\[\begin{equation}
Y = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{k}X_{k} + \varepsilon
\tag{4.24}
\end{equation}\]</span></p>
<p>변수선택이란 반응변수의 변동을 설명할 수 있는 많은 설명변수들 중에서 ’최적’의 조합을 찾는 절차를 의미한다.
변수선택이 필요한 이유로는 모형에 불필요하게 많은 설명변수가 포함이 되면 추정 및 예측 결과에 불확실성이 증가하는 문제가 발생하기 때문이다.
정밀한 추정 및 예측을 하기 위해서는 가능한 모형을 단순하게 만들어야 한다.
또한 많은 설명변수를 포함시키다 보면 비슷한 성질의 변수가 함께 들어갈 가능성이 있는데, 그렇게 되면 다중공선성의 문제가 발생할 수 있게 된다.
적합된 모형에 대한 해석을 쉽게 하기 위해서도 가능한 단순한 모형이 필요하다고 하겠다.</p>
<p>변수선택 방법은 크게 세 가지로 구분할 수 있다.
첫 번째는 검정에 의하여 단계적으로 변수를 선택하는 방법이고, 두 번째는 회귀모형의 평가 측도를 근거로 변수를 선택하는 방법이며, 세 번째는 shrinkage 방법이다.</p>
<p>검정에 의한 변수선택은 SAS나 SPSS 등에서 일반적으로 이루어지는 방법으로서 후진소거법, 전진선택법과 단계별 선택법이 있다.
변수 선택 과정에서 요구되는 계산이 방대하지 않기 때문에 대규모의 설명변수가 있는 경우 손쉽게 중요 변수를 선택할 수 있다는 장점이 있는 방법이지만 변수의 선택과 제거가 ‘한 번에 하나씩’ 이루어지기 때문에 이른바 ‘최적’ 모형을 놓치는 경우가 발생할 수도 있다.
또한 각 단계마다 다중검정이 이루어지기 때문에 일종 오류를 범할 확률이 증가하는 검정의 정당성 문제가 발생할 수도 있다.
그리고 모형의 수립 목적이 예측인 상황에서는 변수선택 과정이 목적과 어울리지 않는다는 문제도 지니고 있는 등 많은 문제점이 있기 때문에 최근에는 거의 사용되지 않는 방법이다.
따라서 이 책에서는 두 번째와 세 번째 변수선택 방법만을 살펴보겠다.</p>
<p>두 번째와 세 번째 변수선택 방법을 알아보기 전에 회귀모형의 평가 측도에 대해 먼저 살펴보도록 하자.</p>
<div id="section-fit-measure" class="section level3 hasAnchor" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> 회귀모형의 평가 측도<a href="multiple-reg.html#section-fit-measure" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>회귀모형을 적합하는 데는 나름의 목적이 있기 마련이다.
따라서 적합된 회귀모형이 그 목적에 부합한지를 적절하게 평가할 수 있는 측도가 필요하다.</p>
<ol style="list-style-type: decimal">
<li>결정계수( <span class="math inline">\(R^{2}\)</span> )</li>
</ol>
<p>결정계수는 반응변수의 총변량 중 회귀모형으로 설명된 변량의 비율을 의미한다.</p>
<p><span class="math display">\[\begin{equation}
R^{2} = \frac{TSS-RSS}{TSS} = 1-\frac{RSS}{TSS}
\end{equation}\]</span></p>
<p>단순회귀모형에서 결정계수는 <span class="math inline">\(Y\)</span> 와 <span class="math inline">\(X\)</span> 의 상관계수의 제곱과 같고, 다중회귀모형에서는 <span class="math inline">\(Y\)</span> 와 <span class="math inline">\(\widehat{Y}\)</span> 의 상관계수의 제곱과 같다.</p>
<p>반응변수의 변량을 충분히 설명하는 것이 주된 목적이라면 결정계수를 모형의 평가 측도로 사용하는 것이 좋을 것이다.
다만, 결정계수는 회귀모형에 설명변수가 추가되면 무조건 증가하는 특성이 있기 때문에 설명변수의 개수가 서로 다른 회귀모형을 비교하는 평가 측도로는 적절하지 않으며, 반드시 설명변수의 개수가 같은 회귀모형을 비교할 때 사용해야 한다.</p>
<ol start="2" style="list-style-type: decimal">
<li>수정결정계수(<span class="math inline">\(adj~R^{2}\)</span> )</li>
</ol>
<p>회귀모형에 설명변수가 추가되면 무조건 값이 증가하는 결정계수의 문제를 보완한 측도이다.
추가된 설명변수가 모형의 설명력 향상에 도움이 되는 경우에만 값이 증가되도록 결정계수를 수정한 측도이다.</p>
<p><span class="math display">\[\begin{equation}
adj~R^{2}=1-\frac{RSS/(n-k-1)}{TSS/(n-1)} = 1-\left( \frac{n-1}{n-k-1} \right)(1-R^{2})
\end{equation}\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>Residual standard error(RSE)</li>
</ol>
<p>잔차제곱합, <span class="math inline">\(RSS\)</span> 는 반응변수의 총변량 중에 회귀모형으로 설명이 되지 않는 변량으로서, 결정계수의 값을 결정하는 요소이며, 회귀모형에 설명변수가 추가되면 무조건 감소하는 특성을 가지고 있다.
이러한 특성은 다음과 같이 잔차제곱합을 자신의 자유도로 나누면 수정이 된다.</p>
<p><span class="math display" id="eq:rse">\[\begin{equation}
RSE = \sqrt{\frac{RSS}{n-k-1}}
\tag{4.25}
\end{equation}\]</span></p>
<p>수정결정계수와 실질적으로 동일한 특성을 가지고 있는 측도로서, 추가된 설명변수가 모형의 설명력 향상에 도움이 되는 경우에만 값이 감소하는 특성을 가지고 있다.</p>
<ol start="4" style="list-style-type: decimal">
<li>Information criteria</li>
</ol>
<p>회귀모형에서 오차항이 정규분포를 한다는 가정을 하고 있기 때문에 Likelihood function을 구성할 수 있는데, 회귀모형에 설명변수를 추가함으로써 모수의 개수가 증가하게 되면 Maximum likelihood의 값도 자연스럽게 증가하게 된다.
이것은 결정계수의 특성과 유사한 것이며, 따라서 설명변수 증가에 대한 penalty를 부과하는 측도를 생각해 볼 수 있다.</p>
<p>AIC와 BIC는 다음과 같이 정의된다.</p>
<p><span class="math display">\[\begin{align*}
AIC &amp;= -2\log \hat{L} + 2K \\
BIC &amp;= -2\log \hat{L} + k\log n
\end{align*}\]</span></p>
<p>단, <span class="math inline">\(\hat{L}\)</span> 은 maximum likelihood function이고, <span class="math inline">\(n\)</span> 은 자료의 크기, <span class="math inline">\(k\)</span> 는 설명변수의 개수이다.
회귀모형에 설명변수가 추가되면, <span class="math inline">\(\hat{L}\)</span> 의 값은 증가하게 되고, 따라서 <span class="math inline">\(-2\log \hat{L}\)</span> 은 감소한다.
설명변수 증가에 대한 penalty로써 AIC는 <span class="math inline">\(2k\)</span>를, BIC는 <span class="math inline">\(k \log n\)</span>를 사용하고 있는데, 설명변수를 추가함으로써 증가된 penalty의 값보다 모형의 적합도 향상으로 감소된 <span class="math inline">\(-2 \log \hat{L}\)</span> 의 값이 더 크다면 AIC나 BIC는 감소하게 된다.
따라서 추가된 설명변수가 모형의 적합도 향상에 도움이 되는 경우에만 값이 감소하는 특성을 가지고 있다.</p>
<ol start="5" style="list-style-type: decimal">
<li><span class="math inline">\(C_{p}\)</span> 통계량</li>
</ol>
<p>정확한 예측 결과가 중요한 평가 기준이라면 다음에 주어진 예측오차제곱합을 기준으로 사용할 수 있을 것이며,</p>
<p><span class="math display">\[\begin{equation}
\frac{1}{\sigma^{2}}\sum_{i} E\left(\widehat{Y}_{i}-E(Y_{i})\right)^{2}
\end{equation}\]</span></p>
<p>추정은 <span class="math inline">\(C_{p}\)</span> 통계량으로 할 수 있다.</p>
<p><span class="math display">\[\begin{equation}
C_{p} = \frac{RSS_{p}}{\hat{\sigma}^{2}} + 2(p+1) - n
\end{equation}\]</span></p>
<p>단, <span class="math inline">\(\hat{\sigma}^{2}\)</span> 는 식 <a href="multiple-reg.html#eq:full-model">(4.24)</a>의 완전모형에서 추정한 오차항의 분산이며, <span class="math inline">\(RSS_{p}\)</span> 는 설명변수의 개수가 <span class="math inline">\(p\)</span> 개인 모형의 잔차제곱합이다.
설명변수의 개수가 <span class="math inline">\(p\)</span> 개인 모형의 경우에는 <span class="math inline">\(E(RSS_{p})=(n-p-1)\sigma^{2}\)</span>가 되기 때문에, <span class="math inline">\(E(C_{p}) \approx (p+1)\)</span> 가 될 것이다.
만일 주어진 회귀모형이 자료를 잘 설명하지 못하는 모형이라면, 잔차제곱합이 매우 큰 값이 될 것이 때문에 <span class="math inline">\(C_{p}\)</span> 값이 <span class="math inline">\((p+1)\)</span> 보다 큰 값이 될 것이다.
따라서 가능한 작은 <span class="math inline">\(p\)</span> 값에서 <span class="math inline">\(C_{p}\)</span> 의 값이 <span class="math inline">\((p+1)\)</span> 과 비슷하거나 작게 되는 모형을 선택하면 된다.
완전모형에서는 <span class="math inline">\(C_{p}=p+1\)</span> 이 된다.</p>
<p><strong><span class="math inline">\(\bullet\)</span></strong> Cross-validation(CV)</p>
<p>CV는 회귀모형의 예측력을 평가할 수 있는 재표본추출(resampling) 기법이다.
지금까지 살펴본 모형 평가 측도는 적합된 모형을 대상으로 계산하는 것인데, 문제는 어떤 자료를 사용해서 모형을 적합하고, 평가 측도값을 계산하는 것이 가장 적절한 것인지이다.</p>
<p>예측 목적으로 설정된 회귀모형의 경우에는 모형 적합에 사용된 자료의 변동 설명보다 적합에 사용되지 않은 새로운 자료에 대한 예측 오차가 더 중요한 평가 요소라고 할 수 있다. 통계모형 적합에 사용되지 않은 새로운 자료에 대한 예측 오차를 test error라고 하는데, 회귀모형의 예측 결과에 대한 정당성을 확보하기 위해서는 낮은 test error가 필수적이다.</p>
<p>CV는 모형 적합에 사용되는 자료인 training data를 이용해서 test error를 추정하기 위한 재표본추출 기법이다. 몇 가지 조금 다른 방법이 있는데, 여기에서는 k-fold CV라는 방법에 대해서만 살펴보겠다. k-fold CV는 training data를 비슷한 크기의 k개 그룹(fold)으로 분리하는 것으로 시작한다. 분리된 k개의 그룹 중 첫 번째 그룹의 자료를 제외하고, 나머지 (k-1)개 그룹의 자료를 사용해서 적합한 회귀모형으로 적합 과정에서 제외된 첫 번째 그룹에 대한 예측을 실시하고, 적절한 평가 측도를 사용해서 예측 오차를 계산한다.
이어서 각 그룹의 자료를 하나씩 차례로 제외하고 나머지 자료로 적합 및 예측하는 과정을 반복하여 k번의 예측을 실시한다. Test error는 k번의 예측에서 각각 발생된 예측 오차의 평균으로 추정하게 된다.</p>
</div>
<div id="section-variable-criterion" class="section level3 hasAnchor" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> 평가 측도에 의한 변수선택<a href="multiple-reg.html#section-variable-criterion" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>평가 측도에 의한 방법은 <a href="multiple-reg.html#section-fit-measure">4.3.1</a>절에서 살펴본 <span class="math inline">\(AIC\)</span>, <span class="math inline">\(BIC\)</span>, <span class="math inline">\(adj~R^{2}\)</span> 및 <span class="math inline">\(C_{p}\)</span> 통계량 등을 기반으로 ‘최적’ 변수를 선택하는 방법이다.
모형에 포함시킬 수 있는 설명변수가 <span class="math inline">\(k\)</span> 개 있다면, 적합 가능한 모형의 개수는 <span class="math inline">\(2^{k}\)</span> 개가 된다.
이 경우에 <span class="math inline">\(2^{k}\)</span> 개의 모형을 다 적합시키고 특정 평가 측도를 기준으로 최적 모형을 선택하는 이른바 ‘Best subset selection’ 방법을 적용해 볼 수 있다.
하지만, 이 방법은 <span class="math inline">\(k\)</span> 의 값이 커진다면 현실적으로 적용하기 쉽지 않다는 문제를 갖고 있다.</p>
<p>다른 방법으로는 특정 평가 측도를 기준으로 변수를 하나씩 모형에 추가하거나 제거하는 ‘Stepwise selection’ 방법을 생각해 볼 수 있다.
이 방법은 검정에 의한 변수선택에서 적용되는 방법으로서 ‘최적’ 모형을 찾지 못할 가능성이 있는 방법이다.
나름의 장점과 단점이 존재하는 방법 중 주어진 상황에 가장 적합한 방법을 선택해서 사용해야 할 것이다.</p>
<p><span class="math inline">\(\bullet\)</span> <strong>Best subset selection</strong></p>
<p><span class="math inline">\(k\)</span> 개 설명변수의 모든 가능한 조합 중 모형의 성능을 최대로 할 수 있는 조합을 찾는 방법이다.
일반적으로 적용되는 방식은 다음과 같다.</p>
<ul>
<li><p><span class="math inline">\(i=1,2,\ldots,k\)</span> 에 대하여 <span class="math inline">\(i\)</span> 개 설명변수가 있는 <span class="math inline">\(\binom{~k~}{i}\)</span> 개 모형을 적합하고, 그 중 결정계수의 값이 가장 큰 모형을 <span class="math inline">\(M_{i}\)</span> 로 지정</p></li>
<li><p><span class="math inline">\(M_{0}, M_{1}, \ldots, M_{k}\)</span> 를 대상으로 <span class="math inline">\(AIC\)</span>, <span class="math inline">\(BIC\)</span>, <span class="math inline">\(C_{p}\)</span>, <span class="math inline">\(adj~R^{2}\)</span> 등을 기준으로 ‘최적’ 모형 선택</p></li>
</ul>
<p><span class="math inline">\(\bullet\)</span> <strong>Stepwise selection</strong></p>
<p>‘한 번에 하나씩’ 이루어지는 선택 과정으로 인하여 ‘최적’ 변수의 조합을 찾지 못할 수 있다는 문제가 있지만, 설명변수의 개수가 많은 경우에 비교적 빠르게 변수선택을 할 수 있다는 장점이 있는 방법이다.
적용할 수 있는 방법에는 모형에 변수를 하나씩 추가하는 Forward stepwise selection과 모형에서 하나씩 변수를 제거하는 Backward elimination, 그리고 두 가지 방식이 혼합된 Hybrid stepwise selection이 있다.</p>
<p><strong>1. Forward stepwise selection</strong></p>
<p>절편만 있는 모형 <span class="math inline">\(M_{0}~(Y=\beta_{0}+\varepsilon)\)</span> 에서 시작하여 단계적으로 변수를 하나씩 모형에 추가하는 방법이다. 추가할 변수를 선택하는 절차는 다음과 같이 두 가지 방식이 있다.</p>
<p><span class="math inline">\(\bullet\)</span> 방식 1</p>
<ul>
<li><p><span class="math inline">\(AIC\)</span> 등을 기준으로 모형의 성능을 최대로 개선시킬 수 있는 변수를 하나씩 모형에 추가</p></li>
<li><p>더 이상 모형의 성능을 개선시킬 변수가 없으면, 절차 종료</p></li>
</ul>
<p><span class="math inline">\(\bullet\)</span> 방식 2</p>
<ul>
<li><p><span class="math inline">\(i=0, \ldots, k-1\)</span> 에 대하여 <span class="math inline">\(M_{i}\)</span> 에 하나의 설명변수를 추가한 <span class="math inline">\((k-i)\)</span> 개 모형 중 결정계수 값이 가장 큰 모형을 <span class="math inline">\(M_{i+1}\)</span> 으로 지정</p></li>
<li><p><span class="math inline">\(M_{0}, M_{1}, \ldots, M_{k}\)</span> 를 대상으로 <span class="math inline">\(AIC\)</span>, <span class="math inline">\(BIC\)</span>, <span class="math inline">\(C_{p}\)</span>, <span class="math inline">\(adj~R^{2}\)</span> 등을 기준으로 ‘최적’ 모형을 하나 선택</p></li>
</ul>
<p>Forward stepwise selection에서는 일단 모형에 포함된 변수에 대해서는 추가적인 확인 과정이 없다.
그러나 이러한 특성은 개별 설명변수의 영향력은 모형에 추가적으로 포함되는 다른 설명변수에 의해 변할 수 있기 때문에 문제가 될 수 있다.</p>
<p><strong>2. Backward stepwise elimination</strong></p>
<p>모든 설명변수가 포함된 full model, <span class="math inline">\(M_{k}\)</span> 에서 시작하여 단계적으로 변수를 하나씩 제거하는 방법이다. 제거할 변수를 선택하는 절차는 다음과 같이 두 가지 방식이 있다.</p>
<p><span class="math inline">\(\bullet\)</span> 방식 1</p>
<ul>
<li><p>제거되면 모형의 성능이 최대로 개선되는 변수를 하나씩 제거</p></li>
<li><p>모형에 포함된 변수 중 어떤 변수라도 제거되면 모형의 성능이 더 나빠질 때 절차 종료</p></li>
</ul>
<p><span class="math inline">\(\bullet\)</span> 방식 2</p>
<ul>
<li><p><span class="math inline">\(i=k, k-1, \ldots, 1\)</span> 에 대하여 <span class="math inline">\(M_{i}\)</span> 에서 하나씩 변수가 제거된 모구 <span class="math inline">\(i\)</span> 개 모형 중 결정계수의 값이 가장 큰 모형을 <span class="math inline">\(M_{i-1}\)</span> 으로 지정</p></li>
<li><p><span class="math inline">\(M_{0}, M_{1}, \ldots, M_{k}\)</span> 를 대상으로 <span class="math inline">\(AIC\)</span>, <span class="math inline">\(BIC\)</span>, <span class="math inline">\(C_{p}\)</span>, <span class="math inline">\(adj~R^{2}\)</span> 등을 기준으로 ‘최적’ 모형을 하나 선택</p></li>
</ul>
<p>Backward stepwise elimination에서는 일단 제거된 변수는 다시 모형에 포함될 수 없는 방식이다.
그러나 이러한 특성은 개별 설명변수의 영향력은 모형에서 다른 설명변수가 제거되면 변할 수 있기 때문에 문제가 될 수 있다.</p>
<p><strong>3. Hybrid stepwise selection</strong></p>
<p>Forward stepwise selection과 Backward stepwise elimination는 일단 모형에 포함되거나 혹은 모형에서 제거된 변수에 대한 추가적인 고려가 불가능한 방식이다.
이러한 특성으로 인하여 ‘최적’ 모형을 찾지 못할 가능성이 있는데, 이 문제는 두 방식의 특성을 혼합시킨 방식을 적용하면 해결할 수 있다.</p>
<ul>
<li><p>Hybrid forward selection : 각 단계별로 변수를 추가한 후에 모형에 포함되어 있는 변수를 대상으로 backward elimination 기법을 적용해서 변수 제거</p></li>
<li><p>Hybrid backward elimination : 각 단계별로 변수를 제거한 후에 이미 제거된 변수를 대상으로 forward selection 기법으로 모형에 추가될 변수 선택</p></li>
</ul>
<p><span class="math inline">\(\bullet\)</span> 변수선택을 위한 함수</p>
<p>Best subset selection은 함수 <code>leaps::regsubsets()</code>로 할 수 있다.
기본적인 사용법은 다음과 같다.</p>
<p><code>regsubsets(formula, data, nbest = 1, nvmax = 8)</code></p>
<p><code>formula</code>와 <code>data</code>는 함수 <code>lm()</code>에서 사용한 방식과 동일하다.
설명변수의 개수가 동일한 모형 중 결정계수의 값이 가장 큰 <code>nbest</code>개 모형을 선택하는데, 이렇게 선택된 모형을 대상으로 다양한 평가 측도를 기준으로 비교할 수 있다.
또한 최대 <code>nvmax</code>개의 설명변수가 포함된 모형을 대상으로 비교를 하기 때문에, <code>nvmax</code>에는 설명변수의 개수를 지정할 필요가 있다.</p>
<p>Stepwise selection은 함수 <code>MASS::stepAIC()</code>로 할 수 있다.
기본적인 사용법은 다음과 같다.</p>
<p><code>stepAIC(object, scope, direction, trace = 1, k = 2)</code></p>
<p><code>object</code>는 stepwise selection을 시작하는 회귀모형을 나타내는 <code>lm</code> 객체를 지정한다.
Forward selection의 경우에는 절편만이 있는 모형인 <code>lm(y ~ 1, data)</code>가 될 것이고, Backward elimination의 경우에는 모든 설명변수가 포함된 모형인 <code>lm(y ~ ., data)</code>가 될 것이다.
<code>scope</code>는 탐색 범위를 나타내는 <code>upper</code>와 <code>lower</code>를 요소가 갖고 있는 리스트를 지정한다.
<code>direction</code>은 탐색 방식을 지정하는데, <code>"forward"</code>는 모형에 포함된 변수는 계속 유지하면서 forward selection 방법을 진행하며, <code>"backward"</code>는 일단 모형에서 제거된 변수는 최종 모형에 포함시키지 않는 방식으로 backward elimination을 진행한다.
또한 <code>"both"</code>는 hybrid stepwise selection 방법을 진행한다.
<code>direction</code>의 디폴트는 <code>scope</code>를 지정하면 <code>"both"</code>가 되지만, <code>scope</code>가 생략되면 <code>"backward"</code>가 된다.
<code>trace</code>는 탐색 과정의 출력 여부를 지정하는 것으로 출력되는 것이 디폴트이며, <code>FALSE</code> 또는 <code>0</code>을 지정하면 출력되지 않는다.
<code>k</code>는 AIC나 BIC의 계산 과정에서 모형에 포함된 변수의 개수만큼 불이익을 주기 위한 상수로서, 디폴트는 AIC 계산을 위한 <code>k = 2</code>이다.
만일 BIC에 의한 단계별 선택법을 적용하고자 한다면 <code>k = log(n)</code>으로 수정해야 한다.
단, <code>n</code>은 데이터 프레임의 행 개수이다.</p>
<p><span class="math inline">\(\bullet\)</span> 예제: <code>mtcars</code></p>
<p><a href="multiple-reg.html#section-multi-fitting">4.1.1</a>절에서 다루었던 <code>mtcars</code>를 대상으로 변수선택을 진행해 보자.
<code>mtcars</code>를 대상으로 앞서 이루어진 주된 분석은 다음과 같다.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="multiple-reg.html#cb68-1" tabindex="-1"></a>mtcars_4 <span class="ot">&lt;-</span> mtcars <span class="sc">|&gt;</span> </span>
<span id="cb68-2"><a href="multiple-reg.html#cb68-2" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">!</span><span class="fu">c</span>(gear, carb)) <span class="sc">|&gt;</span> </span>
<span id="cb68-3"><a href="multiple-reg.html#cb68-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">c</span>(cyl, vs, am), as.factor))</span></code></pre></div>
<p>Best subset selection 방법을 함수 <code>leaps::regsubsets()</code>로 진행해 보자.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="multiple-reg.html#cb69-1" tabindex="-1"></a><span class="fu">library</span>(leaps)</span>
<span id="cb69-2"><a href="multiple-reg.html#cb69-2" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">regsubsets</span>(mpg <span class="sc">~</span> ., mtcars_4, <span class="at">nvmax =</span> <span class="dv">9</span>)</span></code></pre></div>
<p>함수 <code>regsubsets()</code>에 요인을 설명변수로 입력하면, 각 요인에 대한 가변수를 자동으로 생성한다.
그런데 여기에서 주의할 점은 각 가변수를 개별적인 설명변수로 취급한다는 것이다.</p>
<p>모형 <code>fits</code>에 입력된 설명변수는 연속형 변수 5개와 요인 3개인데, 요인의 경우에는 각 가변수를 개별 변수로 인식하기 때문에 <code>cyl</code>에 대한 가변수 2개, <code>vs</code>와 <code>am</code>에 대한 가변수 각각 1개씩 모두 4개의 변수가 있는 것으로 인식한다.
따라서 모형 <code>fits</code>에는 9개의 설명변수가 입력되기 때문에 <code>nvmax = 9</code>를 지정한 것이다.</p>
<p>설명변수의 개수가 <span class="math inline">\(i\)</span> 개 (<span class="math inline">\(i=1, \ldots, 9\)</span>) 인 모형 중 결정계수가 가장 높은 <code>nbest</code>개의 모형은 다음과 같이 함수 <code>summary()</code>로 출력할 수 있다.
모형에 포함되는 변수에는 <code>"*"</code>가 표시되어 있다.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="multiple-reg.html#cb70-1" tabindex="-1"></a><span class="fu">summary</span>(fits)</span>
<span id="cb70-2"><a href="multiple-reg.html#cb70-2" tabindex="-1"></a><span class="do">## Subset selection object</span></span>
<span id="cb70-3"><a href="multiple-reg.html#cb70-3" tabindex="-1"></a><span class="do">## Call: regsubsets.formula(mpg ~ ., mtcars_4, nvmax = 9)</span></span>
<span id="cb70-4"><a href="multiple-reg.html#cb70-4" tabindex="-1"></a><span class="do">## 9 Variables  (and intercept)</span></span>
<span id="cb70-5"><a href="multiple-reg.html#cb70-5" tabindex="-1"></a><span class="do">##      Forced in Forced out</span></span>
<span id="cb70-6"><a href="multiple-reg.html#cb70-6" tabindex="-1"></a><span class="do">## cyl6     FALSE      FALSE</span></span>
<span id="cb70-7"><a href="multiple-reg.html#cb70-7" tabindex="-1"></a><span class="do">## cyl8     FALSE      FALSE</span></span>
<span id="cb70-8"><a href="multiple-reg.html#cb70-8" tabindex="-1"></a><span class="do">## disp     FALSE      FALSE</span></span>
<span id="cb70-9"><a href="multiple-reg.html#cb70-9" tabindex="-1"></a><span class="do">## hp       FALSE      FALSE</span></span>
<span id="cb70-10"><a href="multiple-reg.html#cb70-10" tabindex="-1"></a><span class="do">## drat     FALSE      FALSE</span></span>
<span id="cb70-11"><a href="multiple-reg.html#cb70-11" tabindex="-1"></a><span class="do">## wt       FALSE      FALSE</span></span>
<span id="cb70-12"><a href="multiple-reg.html#cb70-12" tabindex="-1"></a><span class="do">## qsec     FALSE      FALSE</span></span>
<span id="cb70-13"><a href="multiple-reg.html#cb70-13" tabindex="-1"></a><span class="do">## vs1      FALSE      FALSE</span></span>
<span id="cb70-14"><a href="multiple-reg.html#cb70-14" tabindex="-1"></a><span class="do">## am1      FALSE      FALSE</span></span>
<span id="cb70-15"><a href="multiple-reg.html#cb70-15" tabindex="-1"></a><span class="do">## 1 subsets of each size up to 9</span></span>
<span id="cb70-16"><a href="multiple-reg.html#cb70-16" tabindex="-1"></a><span class="do">## Selection Algorithm: exhaustive</span></span>
<span id="cb70-17"><a href="multiple-reg.html#cb70-17" tabindex="-1"></a><span class="do">##          cyl6 cyl8 disp hp  drat wt  qsec vs1 am1</span></span>
<span id="cb70-18"><a href="multiple-reg.html#cb70-18" tabindex="-1"></a><span class="do">## 1  ( 1 ) &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot; &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot; &quot; &quot; &quot;</span></span>
<span id="cb70-19"><a href="multiple-reg.html#cb70-19" tabindex="-1"></a><span class="do">## 2  ( 1 ) &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot; &quot; &quot; &quot;</span></span>
<span id="cb70-20"><a href="multiple-reg.html#cb70-20" tabindex="-1"></a><span class="do">## 3  ( 1 ) &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot; &quot; &quot;  &quot;*&quot; &quot;*&quot;  &quot; &quot; &quot;*&quot;</span></span>
<span id="cb70-21"><a href="multiple-reg.html#cb70-21" tabindex="-1"></a><span class="do">## 4  ( 1 ) &quot;*&quot;  &quot; &quot;  &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot; &quot; &quot;*&quot;</span></span>
<span id="cb70-22"><a href="multiple-reg.html#cb70-22" tabindex="-1"></a><span class="do">## 5  ( 1 ) &quot;*&quot;  &quot; &quot;  &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot;*&quot;</span></span>
<span id="cb70-23"><a href="multiple-reg.html#cb70-23" tabindex="-1"></a><span class="do">## 6  ( 1 ) &quot;*&quot;  &quot; &quot;  &quot; &quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;</span></span>
<span id="cb70-24"><a href="multiple-reg.html#cb70-24" tabindex="-1"></a><span class="do">## 7  ( 1 ) &quot;*&quot;  &quot; &quot;  &quot;*&quot;  &quot;*&quot; &quot; &quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;</span></span>
<span id="cb70-25"><a href="multiple-reg.html#cb70-25" tabindex="-1"></a><span class="do">## 8  ( 1 ) &quot;*&quot;  &quot; &quot;  &quot;*&quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;</span></span>
<span id="cb70-26"><a href="multiple-reg.html#cb70-26" tabindex="-1"></a><span class="do">## 9  ( 1 ) &quot;*&quot;  &quot;*&quot;  &quot;*&quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;  &quot;*&quot; &quot;*&quot;</span></span></code></pre></div>
<p>설명변수가 하나인 경우에는 <code>wt</code>, 두 개인 경우에는 <code>wt</code>와 <code>hp</code>, 세 개인 경우에는 <code>wt</code>, <code>qsec</code>, <code>am</code>이 선택된 것을 알 수 있다.
2개 이상의 가변수가 사용된 범주형 변수의 경우에는 하나의 가변수만 포함되어도 해당 범주형 변수를 모형에 포함시키는 것이 적절할 것이다.</p>
<p>이제 선택된 9개 모형을 대상으로 평가 측도를 비교해 보자.
평가 측도의 비교는 객체 <code>fits</code>를 함수 <code>plot()</code>에 입력하면 된다.
평가 측도는 <code>scale</code>에 지정할 수 있는데, 가능한 키워드는 <code>"bic"</code>, <code>"Cp"</code>, <code>"adjr2"</code>, <code>"r2"</code>이며, 디폴트는 <code>"bic"</code>이다.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="multiple-reg.html#cb71-1" tabindex="-1"></a><span class="fu">plot</span>(fits)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:mtcars4-1"></span>
<img src="_main_files/figure-html/mtcars4-1-1.png" alt="BIC에 의한 비교 결과" width="576" />
<p class="caption">
그림 4.10: BIC에 의한 비교 결과
</p>
</div>
<p>그림 <a href="multiple-reg.html#fig:mtcars4-1">4.10</a>의 X축에는 설명변수가 표시되어 있고, Y축에는 비교 대상이 되는 각 모형의 <span class="math inline">\(BIC\)</span> 의 값이 표시되어 있다.
즉, 그래프의 각 행은 비교 대상이 되는 모형을 나타내는 것이며, X축에 표시된 설명변수가 해당 모형에 포함이 된 것이면 직사각형에 색이 채워진다.
위에서 첫 번째 모형이 <span class="math inline">\(BIC\)</span> 의 값이 가장 작은 모형이며, 변수 <code>wt</code>, <code>qsec</code>, <code>am</code>이 포함된 모형이다.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="multiple-reg.html#cb72-1" tabindex="-1"></a><span class="fu">plot</span>(fits, <span class="at">scale =</span> <span class="st">&quot;adjr2&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:mtcars4-2"></span>
<img src="_main_files/figure-html/mtcars4-2-1.png" alt="수정결정계수에 의한 비교 결과" width="576" />
<p class="caption">
그림 4.11: 수정결정계수에 의한 비교 결과
</p>
</div>
<p>수정결정계수를 평가 측도로 변경하여 변수선택을 진행해 보자.
수정결정계수가 가장 큰 모형으로는 변수 <code>hp</code>, <code>wt</code>, <code>vs</code>, <code>am</code>과 <code>cyl</code>이 포함된 모형이 선택되었다.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="multiple-reg.html#cb73-1" tabindex="-1"></a><span class="fu">plot</span>(fits, <span class="at">scale =</span> <span class="st">&quot;Cp&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:mtcars4-3"></span>
<img src="_main_files/figure-html/mtcars4-3-1.png" alt="Cp에 의한 비교 결과" width="576" />
<p class="caption">
그림 4.12: Cp에 의한 비교 결과
</p>
</div>
<p><span class="math inline">\(C_{p}\)</span> 가 평가 측도인 경우, 선택된 모형은 수정결정계수의 경우와 큰 차이가 없음을 알 수 있다.</p>
<p>Stepwise selection 방법을 함수 <code>MASS::stepAIC()</code>로 진행해 보자.
먼저 모든 설명변수가 포함된 모형과 절편만 있는 모형에 대한 <code>lm</code> 객체를 생성시키자.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="multiple-reg.html#cb74-1" tabindex="-1"></a>fit_full <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> ., mtcars_4)</span>
<span id="cb74-2"><a href="multiple-reg.html#cb74-2" tabindex="-1"></a>fit_null <span class="ot">&lt;-</span> <span class="fu">lm</span>(mpg <span class="sc">~</span> <span class="dv">1</span>, mtcars_4)</span></code></pre></div>
<p>AIC에 의한 forward selection으로 변수선택을 진행해 보자.
<code>fit_null</code>로 시작하고 <code>scope</code>의 <code>upper</code>가 <code>fit_full</code>로 지정하였기 때문에 hybrid forward selection이 수행된다.
변수 <code>wt</code>, <code>cyl</code>, <code>hp</code>, <code>am</code>이 선택되었다.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="multiple-reg.html#cb75-1" tabindex="-1"></a>MASS<span class="sc">::</span><span class="fu">stepAIC</span>(fit_null,</span>
<span id="cb75-2"><a href="multiple-reg.html#cb75-2" tabindex="-1"></a>        <span class="at">scope =</span> <span class="fu">list</span>(<span class="at">lower =</span> fit_null, <span class="at">upper =</span> fit_full),</span>
<span id="cb75-3"><a href="multiple-reg.html#cb75-3" tabindex="-1"></a>        <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb75-4"><a href="multiple-reg.html#cb75-4" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb75-5"><a href="multiple-reg.html#cb75-5" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb75-6"><a href="multiple-reg.html#cb75-6" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ wt + cyl + hp + am, data = mtcars_4)</span></span>
<span id="cb75-7"><a href="multiple-reg.html#cb75-7" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb75-8"><a href="multiple-reg.html#cb75-8" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb75-9"><a href="multiple-reg.html#cb75-9" tabindex="-1"></a><span class="do">## (Intercept)           wt         cyl6         cyl8           hp          am1  </span></span>
<span id="cb75-10"><a href="multiple-reg.html#cb75-10" tabindex="-1"></a><span class="do">##    33.70832     -2.49683     -3.03134     -2.16368     -0.03211      1.80921</span></span></code></pre></div>
<p>AIC에 의한 backward elimination으로 변수선택을 진행해 보자.
Backward elimination은 full model을 시작 모형으로 지정하면 실행된다.
AIC에 의한 forward selection과 같은 결과를 보이고 있다.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="multiple-reg.html#cb76-1" tabindex="-1"></a>MASS<span class="sc">::</span><span class="fu">stepAIC</span>(fit_full, <span class="at">direction =</span> <span class="st">&quot;both&quot;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>) </span>
<span id="cb76-2"><a href="multiple-reg.html#cb76-2" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb76-3"><a href="multiple-reg.html#cb76-3" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb76-4"><a href="multiple-reg.html#cb76-4" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ cyl + hp + wt + am, data = mtcars_4)</span></span>
<span id="cb76-5"><a href="multiple-reg.html#cb76-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb76-6"><a href="multiple-reg.html#cb76-6" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb76-7"><a href="multiple-reg.html#cb76-7" tabindex="-1"></a><span class="do">## (Intercept)         cyl6         cyl8           hp           wt          am1  </span></span>
<span id="cb76-8"><a href="multiple-reg.html#cb76-8" tabindex="-1"></a><span class="do">##    33.70832     -3.03134     -2.16368     -0.03211     -2.49683      1.80921</span></span></code></pre></div>
<p>BIC에 의한 forward selection으로 변수선택을 진행해 보자.
변수 <code>wt</code>와 <code>hp</code>만 선택되어 AIC에 의한 방법과는 다른 결과가 나왔다.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="multiple-reg.html#cb77-1" tabindex="-1"></a>MASS<span class="sc">::</span><span class="fu">stepAIC</span>(fit_null, </span>
<span id="cb77-2"><a href="multiple-reg.html#cb77-2" tabindex="-1"></a>          <span class="at">scope =</span> <span class="fu">list</span>(<span class="at">lower =</span> fit_null, <span class="at">upper =</span> fit_full),</span>
<span id="cb77-3"><a href="multiple-reg.html#cb77-3" tabindex="-1"></a>          <span class="at">k =</span> <span class="fu">log</span>(<span class="fu">nrow</span>(mtcars_4)), </span>
<span id="cb77-4"><a href="multiple-reg.html#cb77-4" tabindex="-1"></a>          <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb77-5"><a href="multiple-reg.html#cb77-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb77-6"><a href="multiple-reg.html#cb77-6" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb77-7"><a href="multiple-reg.html#cb77-7" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ wt + hp, data = mtcars_4)</span></span>
<span id="cb77-8"><a href="multiple-reg.html#cb77-8" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb77-9"><a href="multiple-reg.html#cb77-9" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb77-10"><a href="multiple-reg.html#cb77-10" tabindex="-1"></a><span class="do">## (Intercept)           wt           hp  </span></span>
<span id="cb77-11"><a href="multiple-reg.html#cb77-11" tabindex="-1"></a><span class="do">##    37.22727     -3.87783     -0.03177</span></span></code></pre></div>
<p>BIC에 의한 backward elimination으로 변수선택을 진행해 보자.
변수 <code>wt</code>, <code>qsec</code>, <code>am</code>이 선택되었다.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="multiple-reg.html#cb78-1" tabindex="-1"></a>MASS<span class="sc">::</span><span class="fu">stepAIC</span>(fit_full, <span class="at">direction =</span> <span class="st">&quot;both&quot;</span>, </span>
<span id="cb78-2"><a href="multiple-reg.html#cb78-2" tabindex="-1"></a>          <span class="at">k =</span> <span class="fu">log</span>(<span class="fu">nrow</span>(mtcars_4)), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb78-3"><a href="multiple-reg.html#cb78-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb78-4"><a href="multiple-reg.html#cb78-4" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb78-5"><a href="multiple-reg.html#cb78-5" tabindex="-1"></a><span class="do">## lm(formula = mpg ~ wt + qsec + am, data = mtcars_4)</span></span>
<span id="cb78-6"><a href="multiple-reg.html#cb78-6" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb78-7"><a href="multiple-reg.html#cb78-7" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb78-8"><a href="multiple-reg.html#cb78-8" tabindex="-1"></a><span class="do">## (Intercept)           wt         qsec          am1  </span></span>
<span id="cb78-9"><a href="multiple-reg.html#cb78-9" tabindex="-1"></a><span class="do">##       9.618       -3.917        1.226        2.936</span></span></code></pre></div>
</div>
<div id="section-shrinkage" class="section level3 hasAnchor" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> Shrinkage 방법<a href="multiple-reg.html#section-shrinkage" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><a href="multiple-reg.html#section-variable-criterion">4.3.2</a>절에서 살펴본 변수선택 방식은 설명변수들의 부분집합으로 구성되는 다양한 회귀모형을 적합하고, 그 모형의 평가측도로 ‘최적’ 모형을 선택하는 것이다.
이 방식의 대안으로 최근 많이 사용되는 shrinkage 방법은 회귀계수의 크기에 제약 조건을 부과해서 중요하지 않은 변수의 회귀계수를 0으로 줄어들게 만드는 방법으로서 ridge 회귀모형과 lasso가 여기에 속한다.</p>
<div id="ridge-회귀모형" class="section level4 hasAnchor" number="4.3.3.1">
<h4><span class="header-section-number">4.3.3.1</span> Ridge 회귀모형<a href="multiple-reg.html#ridge-회귀모형" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>식 <a href="multiple-reg.html#eq:full-model">(4.24)</a>에 주어진 회귀모형의 회귀계수를 최소제곱추정법으로 추정하는 것은 <span class="math inline">\(RSS\)</span> 를 최소화하는 회귀계수를 구하는 것을 의미한다.</p>
<p><span class="math display">\[\begin{equation}
RSS = \sum_{i=1}^{n} \left(y_{i}-\beta_{0}-\beta_{1}x_{1i}-\cdots-\beta_{k}x_{ki} \right)^{2}
\end{equation}\]</span></p>
<p>Ridge 회귀모형에서 회귀계수를 추정하는 방법은 단순히 <span class="math inline">\(RSS\)</span> 만을 최소화하는 것이 아니라 회귀계수의 크기를 제한하는 조건이 추가하는 것이다.
Ridge 회귀모형의 회귀계수는 식 <a href="multiple-reg.html#eq:ridge-1">(4.26)</a>을 최소화시키는 값이 된다.</p>
<p><span class="math display" id="eq:ridge-1">\[\begin{equation}
\sum_{i=1}^{n}\left(y_{i}-\beta_{0}-\sum_{j=1}^{k}\beta_{j}x_{ji} \right)^{2} + \lambda \sum_{j=1}^{k}\beta_{j}^{2}
\tag{4.26}
\end{equation}\]</span>
단, <span class="math inline">\(\lambda\)</span> 는 조율모수(tuning parameter)이다.</p>
<p>식 <a href="multiple-reg.html#eq:ridge-1">(4.26)</a>은 두 개의 성분으로 구성되어 있는데, 첫 번째 성분은 <span class="math inline">\(RSS\)</span> 로서 자료에 잘 적합이 되면 작은 값을 갖게 되는 성분이지만, 두번째 성분은 회귀계수의 크기에 비례해서 작아지는 성분이다.
두 번째 성분을 수축 패널티(shrinkage penalty) 성분이라고 하는데, 그것은 대부분의 회귀계수 값이 <span class="math inline">\(0\)</span> 에 가까운 값으로 수축되어야 작은 값을 갖기 때문이다.</p>
<p>두 번째 성분의 영향력은 조율모수 <span class="math inline">\(\lambda\)</span> 의 크기에 의해서 조절되는데, 만일 <span class="math inline">\(\lambda = 0\)</span> 이면 최소제곱추정법과 동일한 결과가 나올 것이고, 반대로 대단히 큰 값이 주어지면 자료의 적합 정도에 관계없이 모든 회귀계수가 <span class="math inline">\(0\)</span> 에 가까운 값을 갖게 될 것이다.
조율모수 <span class="math inline">\(\lambda\)</span> 의 최적 값을 구하는 것은 ridge 회귀모형에서 가장 중요한 작업이 되는데, 일반적으로 cross-validation으로 구하게 된다.</p>
<p>Ridge 회귀모형은 조율모수 <span class="math inline">\(\lambda\)</span> 의 값이 커짐에 따라 자료에 대한 적합 정도는 점점 떨어지게 되는데, 이러한 특성으로 편기(bias)가 증가하게 된다.
하지만 같은 이유로 회귀계수의 추정값은 자료의 변동에 덜 민감하게 되고, 결과적으로 분산이 감소하게 된다.
따라서 최소제곱추정법에 의해 추정된 회귀계수의 분산이 매우 큰 값을 갖게 되는 경우에는 ridge 회귀모형이 대안으로 사용될 수 있다.</p>
<p>Ridge 회귀모형의 회귀계수 추정값은 영향력이 작은 변수의 경우에는 상대적으로 0에 더 근접한 값으로 수축되지만, 정확하게 0의 값이 되는 것은 아니다.
따라서 변수선택의 목적으로 사용하기에는 적절하지 않은 방법이 된다.</p>
</div>
<div id="lasso" class="section level4 hasAnchor" number="4.3.3.2">
<h4><span class="header-section-number">4.3.3.2</span> Lasso<a href="multiple-reg.html#lasso" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Lasso(Least Absolute Shrinkage and Selection Operator)도 ridge 회귀모형처럼 <span class="math inline">\(RSS\)</span> 와 회귀계수의 크기를 제한하는 조건이 추가된 변량을 최소화하는 방식으로 회귀계수를 추정한다.
Lasso 회귀계수는 식 <a href="multiple-reg.html#eq:lasso-1">(4.27)</a>을 최소화시키는 값이 된다.</p>
<p><span class="math display" id="eq:lasso-1">\[\begin{equation}
\sum_{i=1}^{n}\left(y_{i}-\beta_{0}-\sum_{j=1}^{k}\beta_{j}x_{ji} \right)^{2} + \lambda \sum_{j=1}^{k}|\beta_{j}|
\tag{4.27}
\end{equation}\]</span></p>
<p>Lasso도 ridge 회귀모형의 경우처럼 조율모수 <span class="math inline">\(\lambda\)</span> 의 값이 커지게 되면 회귀계수 추정값이 수축하게 된다.
다만, 두 모형의 차이점은 수축 패널티 성분의 형태인데, ridge 회귀모형에서는 <span class="math inline">\(\beta_{j}^{2}\)</span> 을 사용하고, lasso에서는 <span class="math inline">\(|\beta_{j}|\)</span> 을 사용한다.
제곱 형태의 패널티를 사용하면 정확하게 0으로 수축시킬 수 없지만, 절대값 형태의 패널티를 사용하면 0으로 수축시키는 것이 가능하게 된다.
따라서 lasso에서는 영향력이 작은 변수의 회귀계수가 정확하게 0의 값을 갖게 되어, 실질적인 변수선택을 실시하는 것이 된다.</p>
<p><span class="math inline">\(\bullet\)</span> Shrinkage 모형 적합을 위한 함수</p>
<p>Ridge와 lasso 모형은 패키지 <code>glmnet</code>의 함수를 사용해서 적합할 수 있다. 기본적인 적합 함수는 <code>glmnet()</code>이며 사용법은 다음과 같다.</p>
<p><code>glmet(x, y, alpha = 1)</code></p>
<p><code>x</code>에는 설명변수의 행렬을 지정하고, <code>y</code>에는 반응변수의 벡터를 지정한다.
<code>alpha</code>는 0과 1 사이의 값을 갖는 elasticnet 모수인데, <code>alpha = 1</code>이면 lasso, <code>alpha = 0</code>이면 ridge 패널티가 적용된다.
모형 적합은 조율모수 <span class="math inline">\(\lambda\)</span> 에 여러 값을 차례로 입력해서 이루어진다.</p>
<p>최적 <span class="math inline">\(\lambda\)</span> 값을 cross-validation으로 추정한 모형을 적합하기 위해서는 함수 <code>cv.glmnet(x, y, alpha)</code>을 사용하는 것이 더 간편할 수 있다.</p>
<p><span class="math inline">\(\bullet\)</span> 예제: <code>mtcars</code></p>
<p><a href="multiple-reg.html#section-variable-criterion">4.3.2</a>절에서 다루었던 <code>mtcars</code>를 대상으로 shringkage 모형을 적합해 보자.
<code>mtcars</code>를 대상으로 앞서 이루어진 주된 분석은 다음과 같다.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="multiple-reg.html#cb79-1" tabindex="-1"></a>mtcars_4 <span class="ot">&lt;-</span> mtcars <span class="sc">|&gt;</span> </span>
<span id="cb79-2"><a href="multiple-reg.html#cb79-2" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">!</span><span class="fu">c</span>(gear, carb)) <span class="sc">|&gt;</span> </span>
<span id="cb79-3"><a href="multiple-reg.html#cb79-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">c</span>(cyl, vs, am), as.factor))</span></code></pre></div>
<p>패키기 <code>glmnet</code>의 함수를 사용하기 위해 설명변수로 이루어진 행렬과 반응변수 벡터를 생성해보자.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="multiple-reg.html#cb80-1" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(mpg <span class="sc">~</span> ., mtcars_4)[,<span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb80-2"><a href="multiple-reg.html#cb80-2" tabindex="-1"></a>Y <span class="ot">&lt;-</span> mtcars_4<span class="sc">$</span>mpg</span></code></pre></div>
<p>설명변수의 행렬은 각 변수를 함수 <code>cbind()</code>로 연결해서 만들 수 있지만, 변수의 개수가 많거나 요인이 포함되어 있는 경우에는 불편한 방법이 된다.
함수 <code>model.matrix()</code>는 회귀모형의 design matrix인 <span class="math inline">\({\bf X}\)</span> 행렬을 생성하는 기능이 있는 함수이다.
<code>model.matrix(formula, data)</code>의 형태로 <code>lm()</code>과 동일한 방식으로 모형을 정의하면 된다.
생성된 <span class="math inline">\({\bf X}\)</span> 행렬의 첫 번째 열은 절편에 대한 것이기 때문에 설명변수의 행렬에 해당되지 않으므로 제외한다.</p>
<p>먼저 ridge 회귀모형을 적합해보자.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="multiple-reg.html#cb81-1" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span>
<span id="cb81-2"><a href="multiple-reg.html#cb81-2" tabindex="-1"></a>fit_R <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(X, Y, <span class="at">alpha =</span> <span class="dv">0</span>)</span></code></pre></div>
<p>조율모수 <span class="math inline">\(\lambda\)</span> 값의 변화에 따른 회귀계수 추정값의 변화 그래프는 <code>fit_R</code>을 함수 <code>plot()</code>에 입력하면 작성할 수 있다.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="multiple-reg.html#cb82-1" tabindex="-1"></a><span class="fu">plot</span>(fit_R, <span class="at">xvar =</span> <span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:ridge-1"></span>
<img src="_main_files/figure-html/ridge-1-1.png" alt="`lambda` 값의 변화에 따른 ridge 회귀계수 추정값의 변화" width="576" />
<p class="caption">
그림 4.13: <code>lambda</code> 값의 변화에 따른 ridge 회귀계수 추정값의 변화
</p>
</div>
<p>그림 <a href="multiple-reg.html#fig:ridge-1">4.13</a>은 X축에 표시된 <span class="math inline">\(\log \lambda\)</span> 의 값 변화에 따른 회귀계수 추정 결과의 변화를 선으로 나타낸 그래프이다.
<span class="math inline">\(\lambda\)</span> 값이 커지면서 회귀계수가 0으로 수축되고 있는 것을 볼 수 있다.
그래프 위쪽의 눈금은 0이 아닌 회귀계수의 개수를 나타내고 있는데, ridge 회귀계수는 매우 큰 <span class="math inline">\(\lambda\)</span> 값에 대해서도 모두 0이 되지는 않고 있음을 알 수 있다.</p>
<p>Lasso 모형을 적합하고, <span class="math inline">\(\lambda\)</span> 의 값 변화에 따른 회귀계수 추정 결과의 변화를 나타내 보자.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="multiple-reg.html#cb83-1" tabindex="-1"></a>fit_L <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(X, Y, <span class="at">alpha =</span> <span class="dv">1</span>)</span>
<span id="cb83-2"><a href="multiple-reg.html#cb83-2" tabindex="-1"></a><span class="fu">plot</span>(fit_L, <span class="at">xvar =</span> <span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:lasso-1"></span>
<img src="_main_files/figure-html/lasso-1-1.png" alt="`lambda` 값의 변화에 따른 lasso 회귀계수 추정값의 변화" width="576" />
<p class="caption">
그림 4.14: <code>lambda</code> 값의 변화에 따른 lasso 회귀계수 추정값의 변화
</p>
</div>
<p>그림 <a href="multiple-reg.html#fig:lasso-1">4.14</a>을 보면 <span class="math inline">\(\log \lambda\)</span> 값이 증가함에 따라서 0이 아닌 회귀계수의 개수가 줄어들고 있음을 알 수 있다.</p>
<p>최적 <span class="math inline">\(\lambda\)</span> 값을 cross-validation으로 추정한 모형을 함수 <code>cv.glmnet()</code>으로 적합해 보자.
먼저 ridge 회귀모형을 적합해보자.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="multiple-reg.html#cb84-1" tabindex="-1"></a>cvfit_R <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(X, Y, <span class="at">alpha =</span> <span class="dv">0</span>)</span>
<span id="cb84-2"><a href="multiple-reg.html#cb84-2" tabindex="-1"></a>cvfit_R</span>
<span id="cb84-3"><a href="multiple-reg.html#cb84-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb84-4"><a href="multiple-reg.html#cb84-4" tabindex="-1"></a><span class="do">## Call:  cv.glmnet(x = X, y = Y, alpha = 0) </span></span>
<span id="cb84-5"><a href="multiple-reg.html#cb84-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb84-6"><a href="multiple-reg.html#cb84-6" tabindex="-1"></a><span class="do">## Measure: Mean-Squared Error </span></span>
<span id="cb84-7"><a href="multiple-reg.html#cb84-7" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb84-8"><a href="multiple-reg.html#cb84-8" tabindex="-1"></a><span class="do">##     Lambda Index Measure    SE Nonzero</span></span>
<span id="cb84-9"><a href="multiple-reg.html#cb84-9" tabindex="-1"></a><span class="do">## min  0.899    94   6.547 1.694       9</span></span>
<span id="cb84-10"><a href="multiple-reg.html#cb84-10" tabindex="-1"></a><span class="do">## 1se  6.345    73   8.192 2.590       9</span></span></code></pre></div>
<p>10-fold cross-validation을 사용하는 것이 디폴트이며, 반응변수가 연속형인 경우에는 MSE를 최소화시키는 <span class="math inline">\(\lambda\)</span> 값을 추정한다.
<code>min</code>에 해당하는 <code>Lambda</code>는 CV MSE를 최소화시키는 <span class="math inline">\(\lambda\)</span> 값이고, <code>1se</code>에 해당하는 <code>Lambda</code>는 최소 CV MSE <span class="math inline">\(\pm~~ 1 \times SE\)</span> 범위 안에서 최대 <span class="math inline">\(\lambda\)</span> 값이 된다.
<code>1se</code>의 <span class="math inline">\(\lambda\)</span> 값은 최소 CV MSE와는 큰 차이가 없으면서도 가능한 더 많은 회귀계수를 0으로 수축시킬 수 있는 조율모수가 된다.</p>
<p><span class="math inline">\(\lambda\)</span> 값의 변화에 따른 CV의 결과는 다음과 같이 확인할 수 있다.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="multiple-reg.html#cb85-1" tabindex="-1"></a><span class="fu">plot</span>(cvfit_R)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:ridge-2"></span>
<img src="_main_files/figure-html/ridge-2-1.png" alt="`lambda` 값의 변화에 따른 CV MSE의 변화" width="576" />
<p class="caption">
그림 4.15: <code>lambda</code> 값의 변화에 따른 CV MSE의 변화
</p>
</div>
<p>왼쪽에서 첫 번째 수직 점선이 최소 CV MSE에 해당하는 <span class="math inline">\(\lambda\)</span> 값이고, 두 번째 수직 점선이 1SE에 해당하는 <span class="math inline">\(\lambda\)</span> 값이다.</p>
<p>이번에는 lasso 모형을 적합해 보자.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="multiple-reg.html#cb86-1" tabindex="-1"></a>cvfit_L <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(X, Y, <span class="at">alpha =</span> <span class="dv">1</span>)</span>
<span id="cb86-2"><a href="multiple-reg.html#cb86-2" tabindex="-1"></a>cvfit_L</span>
<span id="cb86-3"><a href="multiple-reg.html#cb86-3" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb86-4"><a href="multiple-reg.html#cb86-4" tabindex="-1"></a><span class="do">## Call:  cv.glmnet(x = X, y = Y, alpha = 1) </span></span>
<span id="cb86-5"><a href="multiple-reg.html#cb86-5" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb86-6"><a href="multiple-reg.html#cb86-6" tabindex="-1"></a><span class="do">## Measure: Mean-Squared Error </span></span>
<span id="cb86-7"><a href="multiple-reg.html#cb86-7" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb86-8"><a href="multiple-reg.html#cb86-8" tabindex="-1"></a><span class="do">##     Lambda Index Measure    SE Nonzero</span></span>
<span id="cb86-9"><a href="multiple-reg.html#cb86-9" tabindex="-1"></a><span class="do">## min 0.1983    36   7.779 2.801       7</span></span>
<span id="cb86-10"><a href="multiple-reg.html#cb86-10" tabindex="-1"></a><span class="do">## 1se 1.1617    17  10.195 5.096       5</span></span></code></pre></div>
<p><span class="math inline">\(\lambda\)</span> 값의 변화에 따른 CV의 결과도 확인해 보자.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="multiple-reg.html#cb87-1" tabindex="-1"></a><span class="fu">plot</span>(cvfit_L)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:lasso-2"></span>
<img src="_main_files/figure-html/lasso-2-1.png" alt="`lambda` 값의 변화에 따른 CV MSE의 변화" width="576" />
<p class="caption">
그림 4.16: <code>lambda</code> 값의 변화에 따른 CV MSE의 변화
</p>
</div>
<p>최적 <span class="math inline">\(\lambda\)</span> 값으로 추정된 회귀계수 값은 함수 <code>coef()</code>에 <code>cv.glmnet</code> 객체를 입력하면 확인할 수 있다.
<code>s = "lambda.min"</code>을 추가하면 최소 CV MSE에 해당하는 <span class="math inline">\(\lambda\)</span> 값으로 추정된 회귀계수가 출력되고, 생략하면 디폴트 값인 <code>s = "lambda.1se"</code>가 지정되어 1SE에 해당하는 <span class="math inline">\(\lambda\)</span> 값으로 추정된 회귀계수가 출력된다.</p>
<p>먼저 ridge 회귀계수의 추정값을 출력해 보자.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="multiple-reg.html#cb88-1" tabindex="-1"></a><span class="fu">coef</span>(cvfit_R)</span>
<span id="cb88-2"><a href="multiple-reg.html#cb88-2" tabindex="-1"></a><span class="do">## 10 x 1 sparse Matrix of class &quot;dgCMatrix&quot;</span></span>
<span id="cb88-3"><a href="multiple-reg.html#cb88-3" tabindex="-1"></a><span class="do">##                       s1</span></span>
<span id="cb88-4"><a href="multiple-reg.html#cb88-4" tabindex="-1"></a><span class="do">## (Intercept) 19.022276894</span></span>
<span id="cb88-5"><a href="multiple-reg.html#cb88-5" tabindex="-1"></a><span class="do">## cyl6        -1.079993964</span></span>
<span id="cb88-6"><a href="multiple-reg.html#cb88-6" tabindex="-1"></a><span class="do">## cyl8        -1.072884386</span></span>
<span id="cb88-7"><a href="multiple-reg.html#cb88-7" tabindex="-1"></a><span class="do">## disp        -0.006325128</span></span>
<span id="cb88-8"><a href="multiple-reg.html#cb88-8" tabindex="-1"></a><span class="do">## hp          -0.013135723</span></span>
<span id="cb88-9"><a href="multiple-reg.html#cb88-9" tabindex="-1"></a><span class="do">## drat         1.107153854</span></span>
<span id="cb88-10"><a href="multiple-reg.html#cb88-10" tabindex="-1"></a><span class="do">## wt          -1.124668959</span></span>
<span id="cb88-11"><a href="multiple-reg.html#cb88-11" tabindex="-1"></a><span class="do">## qsec         0.208350553</span></span>
<span id="cb88-12"><a href="multiple-reg.html#cb88-12" tabindex="-1"></a><span class="do">## vs1          1.119832155</span></span>
<span id="cb88-13"><a href="multiple-reg.html#cb88-13" tabindex="-1"></a><span class="do">## am1          1.447003442</span></span></code></pre></div>
<p>Lasso 회귀계수의 추정값을 출력해 보자.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="multiple-reg.html#cb89-1" tabindex="-1"></a><span class="fu">coef</span>(cvfit_L)</span>
<span id="cb89-2"><a href="multiple-reg.html#cb89-2" tabindex="-1"></a><span class="do">## 10 x 1 sparse Matrix of class &quot;dgCMatrix&quot;</span></span>
<span id="cb89-3"><a href="multiple-reg.html#cb89-3" tabindex="-1"></a><span class="do">##                        s1</span></span>
<span id="cb89-4"><a href="multiple-reg.html#cb89-4" tabindex="-1"></a><span class="do">## (Intercept) 32.0056920950</span></span>
<span id="cb89-5"><a href="multiple-reg.html#cb89-5" tabindex="-1"></a><span class="do">## cyl6         .           </span></span>
<span id="cb89-6"><a href="multiple-reg.html#cb89-6" tabindex="-1"></a><span class="do">## cyl8         .           </span></span>
<span id="cb89-7"><a href="multiple-reg.html#cb89-7" tabindex="-1"></a><span class="do">## disp        -0.0008627785</span></span>
<span id="cb89-8"><a href="multiple-reg.html#cb89-8" tabindex="-1"></a><span class="do">## hp          -0.0202233183</span></span>
<span id="cb89-9"><a href="multiple-reg.html#cb89-9" tabindex="-1"></a><span class="do">## drat         0.2171493960</span></span>
<span id="cb89-10"><a href="multiple-reg.html#cb89-10" tabindex="-1"></a><span class="do">## wt          -2.9820129233</span></span>
<span id="cb89-11"><a href="multiple-reg.html#cb89-11" tabindex="-1"></a><span class="do">## qsec         .           </span></span>
<span id="cb89-12"><a href="multiple-reg.html#cb89-12" tabindex="-1"></a><span class="do">## vs1          0.1448971143</span></span>
<span id="cb89-13"><a href="multiple-reg.html#cb89-13" tabindex="-1"></a><span class="do">## am1          .</span></span></code></pre></div>
<p>회귀계수의 추정값이 점으로 찍힌 변수는 해당 회귀계수가 0이라는 것을 의미한다.
Ridge 회귀계수와 lasso 회귀계수의 추정 결과는 최소제곱추정에 의한 추정결과와는 당연히 다르며, 회귀계수 추정에 대한 SE로 계산되지 않는다.
또한 cross-validation에 의한 결과이기 때문에 추정할 때마다 추정결과가 조금 다르게 된다.</p>
</div>
</div>
</div>
<div id="연습문제-2" class="section level2 hasAnchor" number="4.4">
<h2><span class="header-section-number">4.4</span> 연습문제<a href="multiple-reg.html#연습문제-2" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>1.</strong> 반응변수 <span class="math inline">\(Y\)</span> 에 대하여 설명변수 <span class="math inline">\(X_{1}, \ldots, X_{k}\)</span> 의 회귀모형 <span class="math inline">\(\mathbf{Y} = \mathbf{X}\boldsymbol{\beta} + \boldsymbol{\varepsilon}\)</span> 을 설정하고자 한다.</p>
<ul>
<li><p>반응변수의 관찰값 벡터 <span class="math inline">\(\mathbf{Y}\)</span> 를 정의하라.</p></li>
<li><p>설명변수의 관찰값 행렬이며, design matrix라고 불리는 <span class="math inline">\(\mathbf{X}\)</span> 를 정의하라.</p></li>
<li><p>모수 벡터 <span class="math inline">\(\boldsymbol{\beta}\)</span> 를 정의하라.</p></li>
<li><p>오차항 벡터 <span class="math inline">\(\boldsymbol{\varepsilon}\)</span> 를 정의하라.</p></li>
<li><p>모수 벡터 <span class="math inline">\(\boldsymbol{\beta}\)</span> 의 최소제곱추정량 벡터 <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> 은 무엇인가?</p></li>
</ul>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="simple-reg-infer.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="reg-diag.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
